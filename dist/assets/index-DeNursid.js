(function () { const e = document.createElement('link').relList; if (e && e.supports && e.supports('modulepreload')) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i); new MutationObserver((i) => { for (const r of i) if (r.type === 'childList') for (const o of r.addedNodes)o.tagName === 'LINK' && o.rel === 'modulepreload' && s(o) }).observe(document, { childList: !0, subtree: !0 }); function t(i) { const r = {}; return i.integrity && (r.integrity = i.integrity), i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy), i.crossOrigin === 'use-credentials' ? r.credentials = 'include' : i.crossOrigin === 'anonymous' ? r.credentials = 'omit' : r.credentials = 'same-origin', r } function s(i) { if (i.ep) return; i.ep = !0; const r = t(i); fetch(i.href, r) } })(); var Mn, ti; function pa() { if (ti) return Mn; ti = 1; function n(b) { this._maxSize = b, this.clear() }n.prototype.clear = function () { this._size = 0, this._values = Object.create(null) }, n.prototype.get = function (b) { return this._values[b] }, n.prototype.set = function (b, T) { return this._size >= this._maxSize && this.clear(), b in this._values || this._size++, this._values[b] = T }; var e = /[^.^\]^[]+|(?=\[\]|\.\.)/g, t = /^\d+$/, s = /^\d/, i = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, r = /^\s*(['"]?)(.*?)(\1)\s*$/, o = 512, a = new n(o), l = new n(o), c = new n(o); Mn = { Cache: n, split: f, normalizePath: u, setter: function (b) { var T = u(b); return l.get(b) || l.set(b, function (E, v) { for (var S = 0, O = T.length, x = E; S < O - 1;) { var A = T[S]; if (A === '__proto__' || A === 'constructor' || A === 'prototype') return E; x = x[T[S++]] }x[T[S]] = v }) }, getter: function (b, T) { var g = u(b); return c.get(b) || c.set(b, function (v) { for (var S = 0, O = g.length; S < O;) if (v != null || !T)v = v[g[S++]]; else return; return v }) }, join: function (b) { return b.reduce(function (T, g) { return T + (h(g) || t.test(g) ? '[' + g + ']' : (T ? '.' : '') + g) }, '') }, forEach: function (b, T, g) { p(Array.isArray(b) ? b : f(b), T, g) } }; function u(b) { return a.get(b) || a.set(b, f(b).map(function (T) { return T.replace(r, '$2') })) } function f(b) { return b.match(e) || [''] } function p(b, T, g) { var E = b.length, v, S, O, x; for (S = 0; S < E; S++)v = b[S], v && (y(v) && (v = '"' + v + '"'), x = h(v), O = !x && /^\d+$/.test(v), T.call(g, v, x, O, S, b)) } function h(b) { return typeof b == 'string' && b && ['\'', '"'].indexOf(b.charAt(0)) !== -1 } function d(b) { return b.match(s) && !b.match(t) } function _(b) { return i.test(b) } function y(b) { return !h(b) && (d(b) || _(b)) } return Mn } var Er = pa(), Ht = { exports: {} }, ni; function ma() {
  if (ni) return Ht.exports; ni = 1, Ht.exports = function (i) { return n(e(i), i) }, Ht.exports.array = n; function n(i, r) {
    var o = i.length, a = new Array(o), l = {}, c = o, u = t(r), f = s(i); for (r.forEach(function (h) { if (!f.has(h[0]) || !f.has(h[1])) throw new Error('Unknown node. There is an unknown node in the supplied edges.') }); c--;)l[c] || p(i[c], c, new Set()); return a; function p(h, d, _) {
      if (_.has(h)) {
        var y; try { y = ', node was:' + JSON.stringify(h) }
        catch { y = '' } throw new Error('Cyclic dependency' + y)
      } if (!f.has(h)) throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: ' + JSON.stringify(h)); if (!l[d]) { l[d] = !0; var b = u.get(h) || new Set(); if (b = Array.from(b), d = b.length) { _.add(h); do { var T = b[--d]; p(T, f.get(T), _) } while (d); _.delete(h) }a[--o] = h }
    }
  } function e(i) { for (var r = new Set(), o = 0, a = i.length; o < a; o++) { var l = i[o]; r.add(l[0]), r.add(l[1]) } return Array.from(r) } function t(i) { for (var r = new Map(), o = 0, a = i.length; o < a; o++) { var l = i[o]; r.has(l[0]) || r.set(l[0], new Set()), r.has(l[1]) || r.set(l[1], new Set()), r.get(l[0]).add(l[1]) } return r } function s(i) { for (var r = new Map(), o = 0, a = i.length; o < a; o++)r.set(i[o], o); return r } return Ht.exports
}ma(); const ga = Object.prototype.toString, _a = Error.prototype.toString, Ea = RegExp.prototype.toString, ba = typeof Symbol < 'u' ? Symbol.prototype.toString : () => '', ya = /^Symbol\((.*)\)(.*)$/; function va(n) { return n != +n ? 'NaN' : n === 0 && 1 / n < 0 ? '-0' : '' + n } function si(n, e = !1) { if (n == null || n === !0 || n === !1) return '' + n; const t = typeof n; if (t === 'number') return va(n); if (t === 'string') return e ? `"${n}"` : n; if (t === 'function') return '[Function ' + (n.name || 'anonymous') + ']'; if (t === 'symbol') return ba.call(n).replace(ya, 'Symbol($1)'); const s = ga.call(n).slice(8, -1); return s === 'Date' ? isNaN(n.getTime()) ? '' + n : n.toISOString(n) : s === 'Error' || n instanceof Error ? '[' + _a.call(n) + ']' : s === 'RegExp' ? Ea.call(n) : null } function Ae(n, e) { let t = si(n, e); return t !== null ? t : JSON.stringify(n, function (s, i) { let r = si(this[s], e); return r !== null ? r : i }, 2) } function br(n) { return n == null ? [] : [].concat(n) } let yr, vr, wr, wa = /\$\{\s*(\w+)\s*\}/g; yr = Symbol.toStringTag; class ii {
  constructor(e, t, s, i) {
    this.name = void 0, this.message = void 0, this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = void 0, this.inner = void 0, this[yr] = 'Error', this.name = 'ValidationError', this.value = t, this.path = s, this.type = i, this.errors = [], this.inner = [], br(e).forEach((r) => {
      if (q.isError(r)) { this.errors.push(...r.errors); const o = r.inner.length ? r.inner : [r]; this.inner.push(...o) }
      else this.errors.push(r)
    }), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0]
  }
}vr = Symbol.hasInstance; wr = Symbol.toStringTag; class q extends Error {static formatError(e, t) { const s = t.label || t.path || 'this'; return t = Object.assign({}, t, { path: s, originalPath: t.path }), typeof e == 'string' ? e.replace(wa, (i, r) => Ae(t[r])) : typeof e == 'function' ? e(t) : e } static isError(e) { return e && e.name === 'ValidationError' }constructor(e, t, s, i, r) { const o = new ii(e, t, s, i); if (r) return o; super(), this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = [], this.inner = [], this[wr] = 'Error', this.name = o.name, this.message = o.message, this.type = o.type, this.value = o.value, this.path = o.path, this.errors = o.errors, this.inner = o.inner, Error.captureStackTrace && Error.captureStackTrace(this, q) } static [vr](e) { return ii[Symbol.hasInstance](e) || super[Symbol.hasInstance](e) }} let he = { default: '${path} is invalid', required: '${path} is a required field', defined: '${path} must be defined', notNull: '${path} cannot be null', oneOf: '${path} must be one of the following values: ${values}', notOneOf: '${path} must not be one of the following values: ${values}', notType: ({ path: n, type: e, value: t, originalValue: s }) => { const i = s != null && s !== t ? ` (cast from the value \`${Ae(s, !0)}\`).` : '.'; return e !== 'mixed' ? `${n} must be a \`${e}\` type, but the final value was: \`${Ae(t, !0)}\`` + i : `${n} must match the configured type. The validated value was: \`${Ae(t, !0)}\`` + i } }, W = { length: '${path} must be exactly ${length} characters', min: '${path} must be at least ${min} characters', max: '${path} must be at most ${max} characters', matches: '${path} must match the following: "${regex}"', email: '${path} must be a valid email', url: '${path} must be a valid URL', uuid: '${path} must be a valid UUID', datetime: '${path} must be a valid ISO date-time', datetime_precision: '${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits', datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone', trim: '${path} must be a trimmed string', lowercase: '${path} must be a lowercase string', uppercase: '${path} must be a upper case string' }, Sa = { min: '${path} must be greater than or equal to ${min}', max: '${path} must be less than or equal to ${max}', lessThan: '${path} must be less than ${less}', moreThan: '${path} must be greater than ${more}', positive: '${path} must be a positive number', negative: '${path} must be a negative number', integer: '${path} must be an integer' }, is = { min: '${path} field must be later than ${min}', max: '${path} field must be at earlier than ${max}' }, Ta = { isValue: '${path} field must be ${value}' }, Oa = { noUnknown: '${path} field has unspecified keys: ${unknown}', exact: '${path} object contains unknown properties: ${properties}' }, Aa = { min: '${path} field must have at least ${min} items', max: '${path} field must have less than or equal to ${max} items', length: '${path} must have ${length} items' }, Ca = { notType: (n) => { const { path: e, value: t, spec: s } = n, i = s.types.length; if (Array.isArray(t)) { if (t.length < i) return `${e} tuple value has too few items, expected a length of ${i} but got ${t.length} for value: \`${Ae(t, !0)}\``; if (t.length > i) return `${e} tuple value has too many items, expected a length of ${i} but got ${t.length} for value: \`${Ae(t, !0)}\`` } return q.formatError(he.notType, n) } }; Object.assign(Object.create(null), { mixed: he, string: W, number: Sa, date: is, object: Oa, array: Aa, boolean: Ta, tuple: Ca }); const Sr = n => n && n.__isYupSchema__; class an {static fromOptions(e, t) { if (!t.then && !t.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions'); let { is: s, then: i, otherwise: r } = t, o = typeof s == 'function' ? s : (...a) => a.every(l => l === s); return new an(e, (a, l) => { var c; let u = o(...a) ? i : r; return (c = u == null ? void 0 : u(l)) != null ? c : l }) }constructor(e, t) { this.fn = void 0, this.refs = e, this.refs = e, this.fn = t }resolve(e, t) { let s = this.refs.map(r => r.getValue(t == null ? void 0 : t.value, t == null ? void 0 : t.parent, t == null ? void 0 : t.context)), i = this.fn(s, e, t); if (i === void 0 || i === e) return e; if (!Sr(i)) throw new TypeError('conditions must return a schema object'); return i.resolve(t) }} const Ut = { context: '$', value: '.' }; class Lt {constructor(e, t = {}) { if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, typeof e != 'string') throw new TypeError('ref must be a string, got: ' + e); if (this.key = e.trim(), e === '') throw new TypeError('ref must be a non-empty string'); this.isContext = this.key[0] === Ut.context, this.isValue = this.key[0] === Ut.value, this.isSibling = !this.isContext && !this.isValue; let s = this.isContext ? Ut.context : this.isValue ? Ut.value : ''; this.path = this.key.slice(s.length), this.getter = this.path && Er.getter(this.path, !0), this.map = t.map }getValue(e, t, s) { let i = this.isContext ? s : this.isValue ? e : t; return this.getter && (i = this.getter(i || {})), this.map && (i = this.map(i)), i }cast(e, t) { return this.getValue(e, t == null ? void 0 : t.parent, t == null ? void 0 : t.context) }resolve() { return this }describe() { return { type: 'ref', key: this.key } }toString() { return `Ref(${this.key})` } static isRef(e) { return e && e.__isYupRef }}Lt.prototype.__isYupRef = !0; const Ve = n => n == null; function Xe(n) {
  function e({ value: t, path: s = '', options: i, originalValue: r, schema: o }, a, l) {
    const { name: c, test: u, params: f, message: p, skipAbsent: h } = n; let { parent: d, context: _, abortEarly: y = o.spec.abortEarly, disableStackTrace: b = o.spec.disableStackTrace } = i; function T(L) { return Lt.isRef(L) ? L.getValue(t, d, _) : L } function g(L = {}) { const P = Object.assign({ value: t, originalValue: r, label: o.spec.label, path: L.path || s, spec: o.spec, disableStackTrace: L.disableStackTrace || b }, f, L.params); for (const k of Object.keys(P))P[k] = T(P[k]); const R = new q(q.formatError(L.message || p, P), t, P.path, L.type || c, P.disableStackTrace); return R.params = P, R } const E = y ? a : l; let v = { path: s, parent: d, type: c, from: i.from, createError: g, resolve: T, options: i, originalValue: r, schema: o }; const S = (L) => { q.isError(L) ? E(L) : L ? l(null) : E(g()) }, O = (L) => { q.isError(L) ? E(L) : a(L) }; if (h && Ve(t)) return S(!0); let A; try { var D; if (A = u.call(v, t, v), typeof ((D = A) == null ? void 0 : D.then) == 'function') { if (i.sync) throw new Error(`Validation test of type: "${v.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`); return Promise.resolve(A).then(S, O) } }
    catch (L) { O(L); return }S(A)
  } return e.OPTIONS = n, e
} function xa(n, e, t, s = t) { let i, r, o; return e ? (Er.forEach(e, (a, l, c) => { let u = l ? a.slice(1, a.length - 1) : a; n = n.resolve({ context: s, parent: i, value: t }); let f = n.type === 'tuple', p = c ? parseInt(u, 10) : 0; if (n.innerType || f) { if (f && !c) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${o}" must contain an index to the tuple element, e.g. "${o}[0]"`); if (t && p >= t.length) throw new Error(`Yup.reach cannot resolve an array item at index: ${a}, in the path: ${e}. because there is no value at that index. `); i = t, t = t && t[p], n = f ? n.spec.types[p] : n.innerType } if (!c) { if (!n.fields || !n.fields[u]) throw new Error(`The schema does not contain the path: ${e}. (failed at: ${o} which is a type: "${n.type}")`); i = t, t = t && t[u], n = n.fields[u] }r = u, o = l ? '[' + a + ']' : '.' + a }), { schema: n, parent: i, parentPath: r }) : { parent: i, parentPath: e, schema: n } } class ln extends Set {describe() { const e = []; for (const t of this.values())e.push(Lt.isRef(t) ? t.describe() : t); return e }resolveAll(e) { let t = []; for (const s of this.values())t.push(e(s)); return t }clone() { return new ln(this.values()) }merge(e, t) { const s = this.clone(); return e.forEach(i => s.add(i)), t.forEach(i => s.delete(i)), s }} function rt(n, e = new Map()) {
  if (Sr(n) || !n || typeof n != 'object') return n; if (e.has(n)) return e.get(n); let t; if (n instanceof Date)t = new Date(n.getTime()), e.set(n, t); else if (n instanceof RegExp)t = new RegExp(n), e.set(n, t); else if (Array.isArray(n)) { t = new Array(n.length), e.set(n, t); for (let s = 0; s < n.length; s++)t[s] = rt(n[s], e) }
  else if (n instanceof Map) { t = new Map(), e.set(n, t); for (const [s, i] of n.entries())t.set(s, rt(i, e)) }
  else if (n instanceof Set) { t = new Set(), e.set(n, t); for (const s of n)t.add(rt(s, e)) }
  else if (n instanceof Object) { t = {}, e.set(n, t); for (const [s, i] of Object.entries(n))t[s] = rt(i, e) }
  else throw Error(`Unable to clone ${n}`); return t
} class Ce {
  constructor(e) { this.type = void 0, this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this.internalTests = {}, this._whitelist = new ln(), this._blacklist = new ln(), this.exclusiveTests = Object.create(null), this._typeCheck = void 0, this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation(() => { this.typeError(he.notType) }), this.type = e.type, this._typeCheck = e.check, this.spec = Object.assign({ strip: !1, strict: !1, abortEarly: !0, recursive: !0, disableStackTrace: !1, nullable: !1, optional: !0, coerce: !0 }, e == null ? void 0 : e.spec), this.withMutation((t) => { t.nonNullable() }) } get _type() { return this.type }clone(e) { if (this._mutate) return e && Object.assign(this.spec, e), this; const t = Object.create(Object.getPrototypeOf(this)); return t.type = this.type, t._typeCheck = this._typeCheck, t._whitelist = this._whitelist.clone(), t._blacklist = this._blacklist.clone(), t.internalTests = Object.assign({}, this.internalTests), t.exclusiveTests = Object.assign({}, this.exclusiveTests), t.deps = [...this.deps], t.conditions = [...this.conditions], t.tests = [...this.tests], t.transforms = [...this.transforms], t.spec = rt(Object.assign({}, this.spec, e)), t }label(e) { let t = this.clone(); return t.spec.label = e, t }meta(...e) { if (e.length === 0) return this.spec.meta; let t = this.clone(); return t.spec.meta = Object.assign(t.spec.meta || {}, e[0]), t }withMutation(e) { let t = this._mutate; this._mutate = !0; let s = e(this); return this._mutate = t, s }concat(e) { if (!e || e === this) return this; if (e.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${e.type}`); let t = this, s = e.clone(); const i = Object.assign({}, t.spec, s.spec); return s.spec = i, s.internalTests = Object.assign({}, t.internalTests, s.internalTests), s._whitelist = t._whitelist.merge(e._whitelist, e._blacklist), s._blacklist = t._blacklist.merge(e._blacklist, e._whitelist), s.tests = t.tests, s.exclusiveTests = t.exclusiveTests, s.withMutation((r) => { e.tests.forEach((o) => { r.test(o.OPTIONS) }) }), s.transforms = [...t.transforms, ...s.transforms], s }isType(e) { return e == null ? !!(this.spec.nullable && e === null || this.spec.optional && e === void 0) : this._typeCheck(e) }resolve(e) { let t = this; if (t.conditions.length) { let s = t.conditions; t = t.clone(), t.conditions = [], t = s.reduce((i, r) => r.resolve(i, e), t), t = t.resolve(e) } return t }resolveOptions(e) { var t, s, i, r; return Object.assign({}, e, { from: e.from || [], strict: (t = e.strict) != null ? t : this.spec.strict, abortEarly: (s = e.abortEarly) != null ? s : this.spec.abortEarly, recursive: (i = e.recursive) != null ? i : this.spec.recursive, disableStackTrace: (r = e.disableStackTrace) != null ? r : this.spec.disableStackTrace }) }cast(e, t = {}) {
    let s = this.resolve(Object.assign({ value: e }, t)), i = t.assert === 'ignore-optionality', r = s._cast(e, t); if (t.assert !== !1 && !s.isType(r)) {
      if (i && Ve(r)) return r; let o = Ae(e), a = Ae(r); throw new TypeError(`The value of ${t.path || 'field'} could not be cast to a value that satisfies the schema type: "${s.type}". 

attempted value: ${o} 
` + (a !== o ? `result of cast: ${a}` : ''))
    } return r
  }

  _cast(e, t) { let s = e === void 0 ? e : this.transforms.reduce((i, r) => r.call(this, i, e, this), e); return s === void 0 && (s = this.getDefault(t)), s }_validate(e, t = {}, s, i) { let { path: r, originalValue: o = e, strict: a = this.spec.strict } = t, l = e; a || (l = this._cast(l, Object.assign({ assert: !1 }, t))); let c = []; for (let u of Object.values(this.internalTests))u && c.push(u); this.runTests({ path: r, value: l, originalValue: o, options: t, tests: c }, s, (u) => { if (u.length) return i(u, l); this.runTests({ path: r, value: l, originalValue: o, options: t, tests: this.tests }, s, i) }) }runTests(e, t, s) { let i = !1, { tests: r, value: o, originalValue: a, path: l, options: c } = e, u = (_) => { i || (i = !0, t(_, o)) }, f = (_) => { i || (i = !0, s(_, o)) }, p = r.length, h = []; if (!p) return f([]); let d = { value: o, originalValue: a, path: l, options: c, schema: this }; for (let _ = 0; _ < r.length; _++) { const y = r[_]; y(d, u, function (T) { T && (Array.isArray(T) ? h.push(...T) : h.push(T)), --p <= 0 && f(h) }) } }asNestedTest({ key: e, index: t, parent: s, parentPath: i, originalParent: r, options: o }) { const a = e ?? t; if (a == null) throw TypeError('Must include `key` or `index` for nested validations'); const l = typeof a == 'number'; let c = s[a]; const u = Object.assign({}, o, { strict: !0, parent: s, value: c, originalValue: r[a], key: void 0, [l ? 'index' : 'key']: a, path: l || a.includes('.') ? `${i || ''}[${l ? a : `"${a}"`}]` : (i ? `${i}.` : '') + e }); return (f, p, h) => this.resolve(u)._validate(c, u, p, h) }validate(e, t) { var s; let i = this.resolve(Object.assign({}, t, { value: e })), r = (s = t == null ? void 0 : t.disableStackTrace) != null ? s : i.spec.disableStackTrace; return new Promise((o, a) => i._validate(e, t, (l, c) => { q.isError(l) && (l.value = c), a(l) }, (l, c) => { l.length ? a(new q(l, c, void 0, void 0, r)) : o(c) })) }validateSync(e, t) { var s; let i = this.resolve(Object.assign({}, t, { value: e })), r, o = (s = t == null ? void 0 : t.disableStackTrace) != null ? s : i.spec.disableStackTrace; return i._validate(e, Object.assign({}, t, { sync: !0 }), (a, l) => { throw q.isError(a) && (a.value = l), a }, (a, l) => { if (a.length) throw new q(a, e, void 0, void 0, o); r = l }), r }isValid(e, t) { return this.validate(e, t).then(() => !0, (s) => { if (q.isError(s)) return !1; throw s }) }isValidSync(e, t) {
    try { return this.validateSync(e, t), !0 }
    catch (s) { if (q.isError(s)) return !1; throw s }
  }

  _getDefault(e) { let t = this.spec.default; return t == null ? t : typeof t == 'function' ? t.call(this, e) : rt(t) }getDefault(e) { return this.resolve(e || {})._getDefault(e) }default(e) { return arguments.length === 0 ? this._getDefault() : this.clone({ default: e }) }strict(e = !0) { return this.clone({ strict: e }) }nullability(e, t) { const s = this.clone({ nullable: e }); return s.internalTests.nullable = Xe({ message: t, name: 'nullable', test(i) { return i === null ? this.schema.spec.nullable : !0 } }), s }optionality(e, t) { const s = this.clone({ optional: e }); return s.internalTests.optionality = Xe({ message: t, name: 'optionality', test(i) { return i === void 0 ? this.schema.spec.optional : !0 } }), s }optional() { return this.optionality(!0) }defined(e = he.defined) { return this.optionality(!1, e) }nullable() { return this.nullability(!0) }nonNullable(e = he.notNull) { return this.nullability(!1, e) }required(e = he.required) { return this.clone().withMutation(t => t.nonNullable(e).defined(e)) }notRequired() { return this.clone().withMutation(e => e.nullable().optional()) }transform(e) { let t = this.clone(); return t.transforms.push(e), t }test(...e) { let t; if (e.length === 1 ? typeof e[0] == 'function' ? t = { test: e[0] } : t = e[0] : e.length === 2 ? t = { name: e[0], test: e[1] } : t = { name: e[0], message: e[1], test: e[2] }, t.message === void 0 && (t.message = he.default), typeof t.test != 'function') throw new TypeError('`test` is a required parameters'); let s = this.clone(), i = Xe(t), r = t.exclusive || t.name && s.exclusiveTests[t.name] === !0; if (t.exclusive && !t.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test'); return t.name && (s.exclusiveTests[t.name] = !!t.exclusive), s.tests = s.tests.filter(o => !(o.OPTIONS.name === t.name && (r || o.OPTIONS.test === i.OPTIONS.test))), s.tests.push(i), s }when(e, t) { !Array.isArray(e) && typeof e != 'string' && (t = e, e = '.'); let s = this.clone(), i = br(e).map(r => new Lt(r)); return i.forEach((r) => { r.isSibling && s.deps.push(r.key) }), s.conditions.push(typeof t == 'function' ? new an(i, t) : an.fromOptions(i, t)), s }typeError(e) { let t = this.clone(); return t.internalTests.typeError = Xe({ message: e, name: 'typeError', skipAbsent: !0, test(s) { return this.schema._typeCheck(s) ? !0 : this.createError({ params: { type: this.schema.type } }) } }), t }oneOf(e, t = he.oneOf) { let s = this.clone(); return e.forEach((i) => { s._whitelist.add(i), s._blacklist.delete(i) }), s.internalTests.whiteList = Xe({ message: t, name: 'oneOf', skipAbsent: !0, test(i) { let r = this.schema._whitelist, o = r.resolveAll(this.resolve); return o.includes(i) ? !0 : this.createError({ params: { values: Array.from(r).join(', '), resolved: o } }) } }), s }notOneOf(e, t = he.notOneOf) { let s = this.clone(); return e.forEach((i) => { s._blacklist.add(i), s._whitelist.delete(i) }), s.internalTests.blacklist = Xe({ message: t, name: 'notOneOf', test(i) { let r = this.schema._blacklist, o = r.resolveAll(this.resolve); return o.includes(i) ? this.createError({ params: { values: Array.from(r).join(', '), resolved: o } }) : !0 } }), s }strip(e = !0) { let t = this.clone(); return t.spec.strip = e, t }describe(e) { const t = (e ? this.resolve(e) : this).clone(), { label: s, meta: i, optional: r, nullable: o } = t.spec; return { meta: i, label: s, optional: r, nullable: o, default: t.getDefault(e), type: t.type, oneOf: t._whitelist.describe(), notOneOf: t._blacklist.describe(), tests: t.tests.map(l => ({ name: l.OPTIONS.name, params: l.OPTIONS.params })).filter((l, c, u) => u.findIndex(f => f.name === l.name) === c) } }
}Ce.prototype.__isYupSchema__ = !0; for (const n of ['validate', 'validateSync'])Ce.prototype[`${n}At`] = function (e, t, s = {}) { const { parent: i, parentPath: r, schema: o } = xa(this, e, t, s.context); return o[n](i && i[r], Object.assign({}, s, { parent: i, path: e })) }; for (const n of ['equals', 'is'])Ce.prototype[n] = Ce.prototype.oneOf; for (const n of ['not', 'nope'])Ce.prototype[n] = Ce.prototype.notOneOf; const Na = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/; function $a(n) { const e = rs(n); if (!e) return Date.parse ? Date.parse(n) : Number.NaN; if (e.z === void 0 && e.plusMinus === void 0) return new Date(e.year, e.month, e.day, e.hour, e.minute, e.second, e.millisecond).valueOf(); let t = 0; return e.z !== 'Z' && e.plusMinus !== void 0 && (t = e.hourOffset * 60 + e.minuteOffset, e.plusMinus === '+' && (t = 0 - t)), Date.UTC(e.year, e.month, e.day, e.hour, e.minute + t, e.second, e.millisecond) } function rs(n) { var e, t; const s = Na.exec(n); return s ? { year: be(s[1]), month: be(s[2], 1) - 1, day: be(s[3], 1), hour: be(s[4]), minute: be(s[5]), second: be(s[6]), millisecond: s[7] ? be(s[7].substring(0, 3)) : 0, precision: (e = (t = s[7]) == null ? void 0 : t.length) != null ? e : void 0, z: s[8] || void 0, plusMinus: s[9] || void 0, hourOffset: be(s[10]), minuteOffset: be(s[11]) } : null } function be(n, e = 0) { return Number(n) || e } let La = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, Da = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i, Ra = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, Pa = '^\\d{4}-\\d{2}-\\d{2}', ka = '\\d{2}:\\d{2}:\\d{2}', Ia = '(([+-]\\d{2}(:?\\d{2})?)|Z)', Fa = new RegExp(`${Pa}T${ka}(\\.\\d+)?${Ia}$`), Ma = n => Ve(n) || n === n.trim(), Va = {}.toString(); function Tr() { return new Or() } class Or extends Ce {constructor() { super({ type: 'string', check(e) { return e instanceof String && (e = e.valueOf()), typeof e == 'string' } }), this.withMutation(() => { this.transform((e, t, s) => { if (!s.spec.coerce || s.isType(e) || Array.isArray(e)) return e; const i = e != null && e.toString ? e.toString() : e; return i === Va ? e : i }) }) }required(e) { return super.required(e).withMutation(t => t.test({ message: e || he.required, name: 'required', skipAbsent: !0, test: s => !!s.length })) }notRequired() { return super.notRequired().withMutation(e => (e.tests = e.tests.filter(t => t.OPTIONS.name !== 'required'), e)) }length(e, t = W.length) { return this.test({ message: t, name: 'length', exclusive: !0, params: { length: e }, skipAbsent: !0, test(s) { return s.length === this.resolve(e) } }) }min(e, t = W.min) { return this.test({ message: t, name: 'min', exclusive: !0, params: { min: e }, skipAbsent: !0, test(s) { return s.length >= this.resolve(e) } }) }max(e, t = W.max) { return this.test({ name: 'max', exclusive: !0, message: t, params: { max: e }, skipAbsent: !0, test(s) { return s.length <= this.resolve(e) } }) }matches(e, t) { let s = !1, i, r; return t && (typeof t == 'object' ? { excludeEmptyString: s = !1, message: i, name: r } = t : i = t), this.test({ name: r || 'matches', message: i || W.matches, params: { regex: e }, skipAbsent: !0, test: o => o === '' && s || o.search(e) !== -1 }) }email(e = W.email) { return this.matches(La, { name: 'email', message: e, excludeEmptyString: !0 }) }url(e = W.url) { return this.matches(Da, { name: 'url', message: e, excludeEmptyString: !0 }) }uuid(e = W.uuid) { return this.matches(Ra, { name: 'uuid', message: e, excludeEmptyString: !1 }) }datetime(e) { let t = '', s, i; return e && (typeof e == 'object' ? { message: t = '', allowOffset: s = !1, precision: i = void 0 } = e : t = e), this.matches(Fa, { name: 'datetime', message: t || W.datetime, excludeEmptyString: !0 }).test({ name: 'datetime_offset', message: t || W.datetime_offset, params: { allowOffset: s }, skipAbsent: !0, test: (r) => { if (!r || s) return !0; const o = rs(r); return o ? !!o.z : !1 } }).test({ name: 'datetime_precision', message: t || W.datetime_precision, params: { precision: i }, skipAbsent: !0, test: (r) => { if (!r || i == null) return !0; const o = rs(r); return o ? o.precision === i : !1 } }) }ensure() { return this.default('').transform(e => e === null ? '' : e) }trim(e = W.trim) { return this.transform(t => t != null ? t.trim() : t).test({ message: e, name: 'trim', test: Ma }) }lowercase(e = W.lowercase) { return this.transform(t => Ve(t) ? t : t.toLowerCase()).test({ message: e, name: 'string_case', exclusive: !0, skipAbsent: !0, test: t => Ve(t) || t === t.toLowerCase() }) }uppercase(e = W.uppercase) { return this.transform(t => Ve(t) ? t : t.toUpperCase()).test({ message: e, name: 'string_case', exclusive: !0, skipAbsent: !0, test: t => Ve(t) || t === t.toUpperCase() }) }}Tr.prototype = Or.prototype; let ja = new Date(''), Ha = n => Object.prototype.toString.call(n) === '[object Date]'; class ws extends Ce {constructor() { super({ type: 'date', check(e) { return Ha(e) && !isNaN(e.getTime()) } }), this.withMutation(() => { this.transform((e, t, s) => !s.spec.coerce || s.isType(e) || e === null ? e : (e = $a(e), isNaN(e) ? ws.INVALID_DATE : new Date(e))) }) }prepareParam(e, t) { let s; if (Lt.isRef(e))s = e; else { let i = this.cast(e); if (!this._typeCheck(i)) throw new TypeError(`\`${t}\` must be a Date or a value that can be \`cast()\` to a Date`); s = i } return s }min(e, t = is.min) { let s = this.prepareParam(e, 'min'); return this.test({ message: t, name: 'min', exclusive: !0, params: { min: e }, skipAbsent: !0, test(i) { return i >= this.resolve(s) } }) }max(e, t = is.max) { let s = this.prepareParam(e, 'max'); return this.test({ message: t, name: 'max', exclusive: !0, params: { max: e }, skipAbsent: !0, test(i) { return i <= this.resolve(s) } }) }}ws.INVALID_DATE = ja; function Ua(n = []) { return Tr().required('empty').url('invalid').notOneOf(n, 'dubl') } const N = n => typeof n == 'string', yt = () => { let n, e; const t = new Promise((s, i) => { n = s, e = i }); return t.resolve = n, t.reject = e, t }, ri = n => n == null ? '' : '' + n, Ba = (n, e, t) => { n.forEach((s) => { e[s] && (t[s] = e[s]) }) }, Ka = /###/g, oi = n => n && n.indexOf('###') > -1 ? n.replace(Ka, '.') : n, ai = n => !n || N(n), Tt = (n, e, t) => { const s = N(e) ? e.split('.') : e; let i = 0; for (;i < s.length - 1;) { if (ai(n)) return {}; const r = oi(s[i]); !n[r] && t && (n[r] = new t()), Object.prototype.hasOwnProperty.call(n, r) ? n = n[r] : n = {}, ++i } return ai(n) ? {} : { obj: n, k: oi(s[i]) } }, li = (n, e, t) => { const { obj: s, k: i } = Tt(n, e, Object); if (s !== void 0 || e.length === 1) { s[i] = t; return } let r = e[e.length - 1], o = e.slice(0, e.length - 1), a = Tt(n, o, Object); for (;a.obj === void 0 && o.length;)r = `${o[o.length - 1]}.${r}`, o = o.slice(0, o.length - 1), a = Tt(n, o, Object), a != null && a.obj && typeof a.obj[`${a.k}.${r}`] < 'u' && (a.obj = void 0); a.obj[`${a.k}.${r}`] = t }, Wa = (n, e, t, s) => { const { obj: i, k: r } = Tt(n, e, Object); i[r] = i[r] || [], i[r].push(t) }, cn = (n, e) => { const { obj: t, k: s } = Tt(n, e); if (t && Object.prototype.hasOwnProperty.call(t, s)) return t[s] }, za = (n, e, t) => { const s = cn(n, t); return s !== void 0 ? s : cn(e, t) }, Ar = (n, e, t) => { for (const s in e)s !== '__proto__' && s !== 'constructor' && (s in n ? N(n[s]) || n[s] instanceof String || N(e[s]) || e[s] instanceof String ? t && (n[s] = e[s]) : Ar(n[s], e[s], t) : n[s] = e[s]); return n }, Qe = n => n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&'); var qa = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;', '/': '&#x2F;' }; const Ya = n => N(n) ? n.replace(/[&<>"'\/]/g, e => qa[e]) : n; class Ga {constructor(e) { this.capacity = e, this.regExpMap = new Map(), this.regExpQueue = [] }getRegExp(e) { const t = this.regExpMap.get(e); if (t !== void 0) return t; const s = new RegExp(e); return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, s), this.regExpQueue.push(e), s }} const Ja = [' ', ',', '?', '!', ';'], Xa = new Ga(20), Qa = (n, e, t) => { e = e || '', t = t || ''; const s = Ja.filter(o => e.indexOf(o) < 0 && t.indexOf(o) < 0); if (s.length === 0) return !0; const i = Xa.getRegExp(`(${s.map(o => o === '?' ? '\\?' : o).join('|')})`); let r = !i.test(n); if (!r) { const o = n.indexOf(t); o > 0 && !i.test(n.substring(0, o)) && (r = !0) } return r }, os = (n, e, t = '.') => { if (!n) return; if (n[e]) return Object.prototype.hasOwnProperty.call(n, e) ? n[e] : void 0; const s = e.split(t); let i = n; for (let r = 0; r < s.length;) { if (!i || typeof i != 'object') return; let o, a = ''; for (let l = r; l < s.length; ++l) if (l !== r && (a += t), a += s[l], o = i[a], o !== void 0) { if (['string', 'number', 'boolean'].indexOf(typeof o) > -1 && l < s.length - 1) continue; r += l - r + 1; break }i = o } return i }, Ct = n => n == null ? void 0 : n.replace('_', '-'), Za = { type: 'logger', log(n) { this.output('log', n) }, warn(n) { this.output('warn', n) }, error(n) { this.output('error', n) }, output(n, e) { var t, s; (s = (t = console == null ? void 0 : console[n]) == null ? void 0 : t.apply) == null || s.call(t, console, e) } }; class un {constructor(e, t = {}) { this.init(e, t) }init(e, t = {}) { this.prefix = t.prefix || 'i18next:', this.logger = e || Za, this.options = t, this.debug = t.debug }log(...e) { return this.forward(e, 'log', '', !0) }warn(...e) { return this.forward(e, 'warn', '', !0) }error(...e) { return this.forward(e, 'error', '') }deprecate(...e) { return this.forward(e, 'warn', 'WARNING DEPRECATED: ', !0) }forward(e, t, s, i) { return i && !this.debug ? null : (N(e[0]) && (e[0] = `${s}${this.prefix} ${e[0]}`), this.logger[t](e)) }create(e) { return new un(this.logger, { prefix: `${this.prefix}:${e}:`, ...this.options }) }clone(e) { return e = e || this.options, e.prefix = e.prefix || this.prefix, new un(this.logger, e) }} var pe = new un(); class bn {constructor() { this.observers = {} }on(e, t) { return e.split(' ').forEach((s) => { this.observers[s] || (this.observers[s] = new Map()); const i = this.observers[s].get(t) || 0; this.observers[s].set(t, i + 1) }), this }off(e, t) { if (this.observers[e]) { if (!t) { delete this.observers[e]; return } this.observers[e].delete(t) } }emit(e, ...t) { this.observers[e] && Array.from(this.observers[e].entries()).forEach(([i, r]) => { for (let o = 0; o < r; o++)i(...t) }), this.observers['*'] && Array.from(this.observers['*'].entries()).forEach(([i, r]) => { for (let o = 0; o < r; o++)i.apply(i, [e, ...t]) }) }} class ci extends bn {constructor(e, t = { ns: ['translation'], defaultNS: 'translation' }) { super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = '.'), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0) }addNamespaces(e) { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) }removeNamespaces(e) { const t = this.options.ns.indexOf(e); t > -1 && this.options.ns.splice(t, 1) }getResource(e, t, s, i = {}) { var c, u; const r = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, o = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure; let a; e.indexOf('.') > -1 ? a = e.split('.') : (a = [e, t], s && (Array.isArray(s) ? a.push(...s) : N(s) && r ? a.push(...s.split(r)) : a.push(s))); const l = cn(this.data, a); return !l && !t && !s && e.indexOf('.') > -1 && (e = a[0], t = a[1], s = a.slice(2).join('.')), l || !o || !N(s) ? l : os((u = (c = this.data) == null ? void 0 : c[e]) == null ? void 0 : u[t], s, r) }addResource(e, t, s, i, r = { silent: !1 }) { const o = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator; let a = [e, t]; s && (a = a.concat(o ? s.split(o) : s)), e.indexOf('.') > -1 && (a = e.split('.'), i = t, t = a[1]), this.addNamespaces(t), li(this.data, a, i), r.silent || this.emit('added', e, t, s, i) }addResources(e, t, s, i = { silent: !1 }) { for (const r in s)(N(s[r]) || Array.isArray(s[r])) && this.addResource(e, t, r, s[r], { silent: !0 }); i.silent || this.emit('added', e, t, s) }addResourceBundle(e, t, s, i, r, o = { silent: !1, skipCopy: !1 }) { let a = [e, t]; e.indexOf('.') > -1 && (a = e.split('.'), i = s, s = t, t = a[1]), this.addNamespaces(t); let l = cn(this.data, a) || {}; o.skipCopy || (s = JSON.parse(JSON.stringify(s))), i ? Ar(l, s, r) : l = { ...l, ...s }, li(this.data, a, l), o.silent || this.emit('added', e, t, s) }removeResourceBundle(e, t) { this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit('removed', e, t) }hasResourceBundle(e, t) { return this.getResource(e, t) !== void 0 }getResourceBundle(e, t) { return t || (t = this.options.defaultNS), this.getResource(e, t) }getDataByLanguage(e) { return this.data[e] }hasLanguageSomeTranslations(e) { const t = this.getDataByLanguage(e); return !!(t && Object.keys(t) || []).find(i => t[i] && Object.keys(t[i]).length > 0) }toJSON() { return this.data }} var Cr = { processors: {}, addPostProcessor(n) { this.processors[n.name] = n }, handle(n, e, t, s, i) { return n.forEach((r) => { var o; e = ((o = this.processors[r]) == null ? void 0 : o.process(e, t, s, i)) ?? e }), e } }; const ui = {}, fi = n => !N(n) && typeof n != 'boolean' && typeof n != 'number'; class fn extends bn {
  constructor(e, t = {}) { super(), Ba(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = '.'), this.logger = pe.create('translator') }changeLanguage(e) { e && (this.language = e) }exists(e, t = { interpolation: {} }) { const s = { ...t }; if (e == null) return !1; const i = this.resolve(e, s); return (i == null ? void 0 : i.res) !== void 0 }extractFromKey(e, t) { let s = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator; s === void 0 && (s = ':'); const i = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator; let r = t.ns || this.options.defaultNS || []; const o = s && e.indexOf(s) > -1, a = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !Qa(e, s, i); if (o && !a) { const l = e.match(this.interpolator.nestingRegexp); if (l && l.length > 0) return { key: e, namespaces: N(r) ? [r] : r }; const c = e.split(s); (s !== i || s === i && this.options.ns.indexOf(c[0]) > -1) && (r = c.shift()), e = c.join(i) } return { key: e, namespaces: N(r) ? [r] : r } }translate(e, t, s) {
    let i = typeof t == 'object' ? { ...t } : t; if (typeof i != 'object' && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), typeof options == 'object' && (i = { ...i }), i || (i = {}), e == null) return ''; Array.isArray(e) || (e = [String(e)]); const r = i.returnDetails !== void 0 ? i.returnDetails : this.options.returnDetails, o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, { key: a, namespaces: l } = this.extractFromKey(e[e.length - 1], i), c = l[l.length - 1]; let u = i.nsSeparator !== void 0 ? i.nsSeparator : this.options.nsSeparator; u === void 0 && (u = ':'); const f = i.lng || this.language, p = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if ((f == null ? void 0 : f.toLowerCase()) === 'cimode') return p ? r ? { res: `${c}${u}${a}`, usedKey: a, exactUsedKey: a, usedLng: f, usedNS: c, usedParams: this.getUsedParamsDetails(i) } : `${c}${u}${a}` : r ? { res: a, usedKey: a, exactUsedKey: a, usedLng: f, usedNS: c, usedParams: this.getUsedParamsDetails(i) } : a; const h = this.resolve(e, i); let d = h == null ? void 0 : h.res; const _ = (h == null ? void 0 : h.usedKey) || a, y = (h == null ? void 0 : h.exactUsedKey) || a, b = ['[object Number]', '[object Function]', '[object RegExp]'], T = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays, g = !this.i18nFormat || this.i18nFormat.handleAsObject, E = i.count !== void 0 && !N(i.count), v = fn.hasDefaultValue(i), S = E ? this.pluralResolver.getSuffix(f, i.count, i) : '', O = i.ordinal && E ? this.pluralResolver.getSuffix(f, i.count, { ordinal: !1 }) : '', x = E && !i.ordinal && i.count === 0, A = x && i[`defaultValue${this.options.pluralSeparator}zero`] || i[`defaultValue${S}`] || i[`defaultValue${O}`] || i.defaultValue; let D = d; g && !d && v && (D = A); const L = fi(D), P = Object.prototype.toString.apply(D); if (g && D && L && b.indexOf(P) < 0 && !(N(T) && Array.isArray(D))) { if (!i.returnObjects && !this.options.returnObjects) { this.options.returnedObjectHandler || this.logger.warn('accessing an object - but returnObjects options is not enabled!'); const R = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(_, D, { ...i, ns: l }) : `key '${a} (${this.language})' returned an object instead of string.`; return r ? (h.res = R, h.usedParams = this.getUsedParamsDetails(i), h) : R } if (o) { const R = Array.isArray(D), k = R ? [] : {}, ce = R ? y : _; for (const I in D) if (Object.prototype.hasOwnProperty.call(D, I)) { const F = `${ce}${o}${I}`; v && !d ? k[I] = this.translate(F, { ...i, defaultValue: fi(A) ? A[I] : void 0, joinArrays: !1, ns: l }) : k[I] = this.translate(F, { ...i, joinArrays: !1, ns: l }), k[I] === F && (k[I] = D[I]) }d = k } }
    else if (g && N(T) && Array.isArray(d))d = d.join(T), d && (d = this.extendTranslation(d, e, i, s)); else { let R = !1, k = !1; !this.isValidLookup(d) && v && (R = !0, d = A), this.isValidLookup(d) || (k = !0, d = a); const I = (i.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && k ? void 0 : d, F = v && A !== d && this.options.updateMissing; if (k || R || F) { if (this.logger.log(F ? 'updateKey' : 'missingKey', f, c, a, F ? A : d), o) { const V = this.resolve(a, { ...i, keySeparator: !1 }); V && V.res && this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.') } let ue = []; const te = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language); if (this.options.saveMissingTo === 'fallback' && te && te[0]) for (let V = 0; V < te.length; V++)ue.push(te[V]); else this.options.saveMissingTo === 'all' ? ue = this.languageUtils.toResolveHierarchy(i.lng || this.language) : ue.push(i.lng || this.language); const ke = (V, X, fe) => { var oe; const Ee = v && fe !== d ? fe : I; this.options.missingKeyHandler ? this.options.missingKeyHandler(V, c, X, Ee, F, i) : (oe = this.backendConnector) != null && oe.saveMissing && this.backendConnector.saveMissing(V, c, X, Ee, F, i), this.emit('missingKey', V, c, X, d) }; this.options.saveMissing && (this.options.saveMissingPlurals && E ? ue.forEach((V) => { const X = this.pluralResolver.getSuffixes(V, i); x && i[`defaultValue${this.options.pluralSeparator}zero`] && X.indexOf(`${this.options.pluralSeparator}zero`) < 0 && X.push(`${this.options.pluralSeparator}zero`), X.forEach((fe) => { ke([V], a + fe, i[`defaultValue${fe}`] || A) }) }) : ke(ue, a, A)) }d = this.extendTranslation(d, e, i, h, s), k && d === a && this.options.appendNamespaceToMissingKey && (d = `${c}${u}${a}`), (k || R) && this.options.parseMissingKeyHandler && (d = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${c}${u}${a}` : a, R ? d : void 0, i)) } return r ? (h.res = d, h.usedParams = this.getUsedParamsDetails(i), h) : d
  }

  extendTranslation(e, t, s, i, r) { var l, c; if ((l = this.i18nFormat) != null && l.parse)e = this.i18nFormat.parse(e, { ...this.options.interpolation.defaultVariables, ...s }, s.lng || this.language || i.usedLng, i.usedNS, i.usedKey, { resolved: i }); else if (!s.skipInterpolation) { s.interpolation && this.interpolator.init({ ...s, interpolation: { ...this.options.interpolation, ...s.interpolation } }); const u = N(e) && (((c = s == null ? void 0 : s.interpolation) == null ? void 0 : c.skipOnVariables) !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); let f; if (u) { const h = e.match(this.interpolator.nestingRegexp); f = h && h.length } let p = s.replace && !N(s.replace) ? s.replace : s; if (this.options.interpolation.defaultVariables && (p = { ...this.options.interpolation.defaultVariables, ...p }), e = this.interpolator.interpolate(e, p, s.lng || this.language || i.usedLng, s), u) { const h = e.match(this.interpolator.nestingRegexp), d = h && h.length; f < d && (s.nest = !1) }!s.lng && i && i.res && (s.lng = this.language || i.usedLng), s.nest !== !1 && (e = this.interpolator.nest(e, (...h) => (r == null ? void 0 : r[0]) === h[0] && !s.context ? (this.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${t[0]}`), null) : this.translate(...h, t), s)), s.interpolation && this.interpolator.reset() } const o = s.postProcess || this.options.postProcess, a = N(o) ? [o] : o; return e != null && (a != null && a.length) && s.applyPostProcessor !== !1 && (e = Cr.handle(a, e, t, this.options && this.options.postProcessPassResolved ? { i18nResolved: { ...i, usedParams: this.getUsedParamsDetails(s) }, ...s } : s, this)), e }resolve(e, t = {}) { let s, i, r, o, a; return N(e) && (e = [e]), e.forEach((l) => { if (this.isValidLookup(s)) return; const c = this.extractFromKey(l, t), u = c.key; i = u; let f = c.namespaces; this.options.fallbackNS && (f = f.concat(this.options.fallbackNS)); const p = t.count !== void 0 && !N(t.count), h = p && !t.ordinal && t.count === 0, d = t.context !== void 0 && (N(t.context) || typeof t.context == 'number') && t.context !== '', _ = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng); f.forEach((y) => { var b, T; this.isValidLookup(s) || (a = y, !ui[`${_[0]}-${y}`] && ((b = this.utils) != null && b.hasLoadedNamespace) && !((T = this.utils) != null && T.hasLoadedNamespace(a)) && (ui[`${_[0]}-${y}`] = !0, this.logger.warn(`key "${i}" for languages "${_.join(', ')}" won't get resolved as namespace "${a}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!')), _.forEach((g) => { var S; if (this.isValidLookup(s)) return; o = g; const E = [u]; if ((S = this.i18nFormat) != null && S.addLookupKeys) this.i18nFormat.addLookupKeys(E, u, g, y, t); else { let O; p && (O = this.pluralResolver.getSuffix(g, t.count, t)); const x = `${this.options.pluralSeparator}zero`, A = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`; if (p && (E.push(u + O), t.ordinal && O.indexOf(A) === 0 && E.push(u + O.replace(A, this.options.pluralSeparator)), h && E.push(u + x)), d) { const D = `${u}${this.options.contextSeparator}${t.context}`; E.push(D), p && (E.push(D + O), t.ordinal && O.indexOf(A) === 0 && E.push(D + O.replace(A, this.options.pluralSeparator)), h && E.push(D + x)) } } let v; for (;v = E.pop();) this.isValidLookup(s) || (r = v, s = this.getResource(g, y, v, t)) })) }) }), { res: s, usedKey: i, exactUsedKey: r, usedLng: o, usedNS: a } }isValidLookup(e) { return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === '') }getResource(e, t, s, i = {}) { var r; return (r = this.i18nFormat) != null && r.getResource ? this.i18nFormat.getResource(e, t, s, i) : this.resourceStore.getResource(e, t, s, i) }getUsedParamsDetails(e = {}) { const t = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'], s = e.replace && !N(e.replace); let i = s ? e.replace : e; if (s && typeof e.count < 'u' && (i.count = e.count), this.options.interpolation.defaultVariables && (i = { ...this.options.interpolation.defaultVariables, ...i }), !s) { i = { ...i }; for (const r of t) delete i[r] } return i } static hasDefaultValue(e) { const t = 'defaultValue'; for (const s in e) if (Object.prototype.hasOwnProperty.call(e, s) && t === s.substring(0, t.length) && e[s] !== void 0) return !0; return !1 }
} class di {
  constructor(e) { this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = pe.create('languageUtils') }getScriptPartFromCode(e) { if (e = Ct(e), !e || e.indexOf('-') < 0) return null; const t = e.split('-'); return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === 'x') ? null : this.formatLanguageCode(t.join('-')) }getLanguagePartFromCode(e) { if (e = Ct(e), !e || e.indexOf('-') < 0) return e; const t = e.split('-'); return this.formatLanguageCode(t[0]) }formatLanguageCode(e) {
    if (N(e) && e.indexOf('-') > -1) {
      let t; try { t = Intl.getCanonicalLocales(e)[0] }
      catch {} return t && this.options.lowerCaseLng && (t = t.toLowerCase()), t || (this.options.lowerCaseLng ? e.toLowerCase() : e)
    } return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e
  }

  isSupportedCode(e) { return (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1 }getBestMatchFromCodes(e) { if (!e) return null; let t; return e.forEach((s) => { if (t) return; const i = this.formatLanguageCode(s); (!this.options.supportedLngs || this.isSupportedCode(i)) && (t = i) }), !t && this.options.supportedLngs && e.forEach((s) => { if (t) return; const i = this.getScriptPartFromCode(s); if (this.isSupportedCode(i)) return t = i; const r = this.getLanguagePartFromCode(s); if (this.isSupportedCode(r)) return t = r; t = this.options.supportedLngs.find((o) => { if (o === r) return o; if (!(o.indexOf('-') < 0 && r.indexOf('-') < 0) && (o.indexOf('-') > 0 && r.indexOf('-') < 0 && o.substring(0, o.indexOf('-')) === r || o.indexOf(r) === 0 && r.length > 1)) return o }) }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t }getFallbackCodes(e, t) { if (!e) return []; if (typeof e == 'function' && (e = e(t)), N(e) && (e = [e]), Array.isArray(e)) return e; if (!t) return e.default || []; let s = e[t]; return s || (s = e[this.getScriptPartFromCode(t)]), s || (s = e[this.formatLanguageCode(t)]), s || (s = e[this.getLanguagePartFromCode(t)]), s || (s = e.default), s || [] }toResolveHierarchy(e, t) { const s = this.getFallbackCodes((t === !1 ? [] : t) || this.options.fallbackLng || [], e), i = [], r = (o) => { o && (this.isSupportedCode(o) ? i.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`)) }; return N(e) && (e.indexOf('-') > -1 || e.indexOf('_') > -1) ? (this.options.load !== 'languageOnly' && r(this.formatLanguageCode(e)), this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly' && r(this.getScriptPartFromCode(e)), this.options.load !== 'currentOnly' && r(this.getLanguagePartFromCode(e))) : N(e) && r(this.formatLanguageCode(e)), s.forEach((o) => { i.indexOf(o) < 0 && r(this.formatLanguageCode(o)) }), i }
} const hi = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 }, pi = { select: n => n === 1 ? 'one' : 'other', resolvedOptions: () => ({ pluralCategories: ['one', 'other'] }) }; class el {
  constructor(e, t = {}) { this.languageUtils = e, this.options = t, this.logger = pe.create('pluralResolver'), this.pluralRulesCache = {} }addRule(e, t) { this.rules[e] = t }clearCache() { this.pluralRulesCache = {} }getRule(e, t = {}) {
    const s = Ct(e === 'dev' ? 'en' : e), i = t.ordinal ? 'ordinal' : 'cardinal', r = JSON.stringify({ cleanedCode: s, type: i }); if (r in this.pluralRulesCache) return this.pluralRulesCache[r]; let o; try { o = new Intl.PluralRules(s, { type: i }) }
    catch { if (!Intl) return this.logger.error('No Intl support, please use an Intl polyfill!'), pi; if (!e.match(/-|_/)) return pi; const l = this.languageUtils.getLanguagePartFromCode(e); o = this.getRule(l, t) } return this.pluralRulesCache[r] = o, o
  }

  needsPlural(e, t = {}) { let s = this.getRule(e, t); return s || (s = this.getRule('dev', t)), (s == null ? void 0 : s.resolvedOptions().pluralCategories.length) > 1 }getPluralFormsOfKey(e, t, s = {}) { return this.getSuffixes(e, s).map(i => `${t}${i}`) }getSuffixes(e, t = {}) { let s = this.getRule(e, t); return s || (s = this.getRule('dev', t)), s ? s.resolvedOptions().pluralCategories.sort((i, r) => hi[i] - hi[r]).map(i => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ''}${i}`) : [] }getSuffix(e, t, s = {}) { const i = this.getRule(e, s); return i ? `${this.options.prepend}${s.ordinal ? `ordinal${this.options.prepend}` : ''}${i.select(t)}` : (this.logger.warn(`no plural rule found for: ${e}`), this.getSuffix('dev', t, s)) }
} const mi = (n, e, t, s = '.', i = !0) => { let r = za(n, e, t); return !r && i && N(t) && (r = os(n, t, s), r === void 0 && (r = os(e, t, s))), r }, Vn = n => n.replace(/\$/g, '$$$$'); class tl {
  constructor(e = {}) { var t; this.logger = pe.create('interpolator'), this.options = e, this.format = ((t = e == null ? void 0 : e.interpolation) == null ? void 0 : t.format) || (s => s), this.init(e) }init(e = {}) { e.interpolation || (e.interpolation = { escapeValue: !0 }); const { escape: t, escapeValue: s, useRawValueToEscape: i, prefix: r, prefixEscaped: o, suffix: a, suffixEscaped: l, formatSeparator: c, unescapeSuffix: u, unescapePrefix: f, nestingPrefix: p, nestingPrefixEscaped: h, nestingSuffix: d, nestingSuffixEscaped: _, nestingOptionsSeparator: y, maxReplaces: b, alwaysFormat: T } = e.interpolation; this.escape = t !== void 0 ? t : Ya, this.escapeValue = s !== void 0 ? s : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = r ? Qe(r) : o || '{{', this.suffix = a ? Qe(a) : l || '}}', this.formatSeparator = c || ',', this.unescapePrefix = u ? '' : f || '-', this.unescapeSuffix = this.unescapePrefix ? '' : u || '', this.nestingPrefix = p ? Qe(p) : h || Qe('$t('), this.nestingSuffix = d ? Qe(d) : _ || Qe(')'), this.nestingOptionsSeparator = y || ',', this.maxReplaces = b || 1e3, this.alwaysFormat = T !== void 0 ? T : !1, this.resetRegExp() }reset() { this.options && this.init(this.options) }resetRegExp() { const e = (t, s) => (t == null ? void 0 : t.source) === s ? (t.lastIndex = 0, t) : new RegExp(s, 'g'); this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`) }interpolate(e, t, s, i) {
    var h; let r, o, a; const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = (d) => { if (d.indexOf(this.formatSeparator) < 0) { const T = mi(t, l, d, this.options.keySeparator, this.options.ignoreJSONStructure); return this.alwaysFormat ? this.format(T, void 0, s, { ...i, ...t, interpolationkey: d }) : T } const _ = d.split(this.formatSeparator), y = _.shift().trim(), b = _.join(this.formatSeparator).trim(); return this.format(mi(t, l, y, this.options.keySeparator, this.options.ignoreJSONStructure), b, s, { ...i, ...t, interpolationkey: y }) }; this.resetRegExp(); const u = (i == null ? void 0 : i.missingInterpolationHandler) || this.options.missingInterpolationHandler, f = ((h = i == null ? void 0 : i.interpolation) == null ? void 0 : h.skipOnVariables) !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex: this.regexpUnescape, safeValue: d => Vn(d) }, { regex: this.regexp, safeValue: d => this.escapeValue ? Vn(this.escape(d)) : Vn(d) }].forEach((d) => {
      for (a = 0; r = d.regex.exec(e);) {
        const _ = r[1].trim(); if (o = c(_), o === void 0) if (typeof u == 'function') { const b = u(e, r, i); o = N(b) ? b : '' }
        else if (i && Object.prototype.hasOwnProperty.call(i, _))o = ''; else if (f) { o = r[0]; continue }
        else this.logger.warn(`missed to pass in variable ${_} for interpolating ${e}`), o = ''; else !N(o) && !this.useRawValueToEscape && (o = ri(o)); const y = d.safeValue(o); if (e = e.replace(r[0], y), f ? (d.regex.lastIndex += o.length, d.regex.lastIndex -= r[0].length) : d.regex.lastIndex = 0, a++, a >= this.maxReplaces) break
      }
    }), e
  }

  nest(e, t, s = {}) {
    let i, r, o; const a = (l, c) => {
      const u = this.nestingOptionsSeparator; if (l.indexOf(u) < 0) return l; const f = l.split(new RegExp(`${u}[ ]*{`)); let p = `{${f[1]}`; l = f[0], p = this.interpolate(p, o); const h = p.match(/'/g), d = p.match(/"/g); (((h == null ? void 0 : h.length) ?? 0) % 2 === 0 && !d || d.length % 2 !== 0) && (p = p.replace(/'/g, '"')); try { o = JSON.parse(p), c && (o = { ...c, ...o }) }
      catch (_) { return this.logger.warn(`failed parsing options string in nesting for key ${l}`, _), `${l}${u}${p}` } return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, l
    }; for (;i = this.nestingRegexp.exec(e);) { let l = []; o = { ...s }, o = o.replace && !N(o.replace) ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue; let c = !1; if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) { const u = i[1].split(this.formatSeparator).map(f => f.trim()); i[1] = u.shift(), l = u, c = !0 } if (r = t(a.call(this, i[1].trim(), o), o), r && i[0] === e && !N(r)) return r; N(r) || (r = ri(r)), r || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${e}`), r = ''), c && (r = l.reduce((u, f) => this.format(u, f, s.lng, { ...s, interpolationkey: i[1].trim() }), r.trim())), e = e.replace(i[0], r), this.regexp.lastIndex = 0 } return e
  }
} const nl = (n) => { let e = n.toLowerCase().trim(); const t = {}; if (n.indexOf('(') > -1) { const s = n.split('('); e = s[0].toLowerCase().trim(); const i = s[1].substring(0, s[1].length - 1); e === 'currency' && i.indexOf(':') < 0 ? t.currency || (t.currency = i.trim()) : e === 'relativetime' && i.indexOf(':') < 0 ? t.range || (t.range = i.trim()) : i.split(';').forEach((o) => { if (o) { const [a, ...l] = o.split(':'), c = l.join(':').trim().replace(/^'+|'+$/g, ''), u = a.trim(); t[u] || (t[u] = c), c === 'false' && (t[u] = !1), c === 'true' && (t[u] = !0), isNaN(c) || (t[u] = parseInt(c, 10)) } }) } return { formatName: e, formatOptions: t } }, gi = (n) => { const e = {}; return (t, s, i) => { let r = i; i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (r = { ...r, [i.interpolationkey]: void 0 }); const o = s + JSON.stringify(r); let a = e[o]; return a || (a = n(Ct(s), i), e[o] = a), a(t) } }, sl = n => (e, t, s) => n(Ct(t), s)(e); class il {
  constructor(e = {}) { this.logger = pe.create('formatter'), this.options = e, this.init(e) }init(e, t = { interpolation: {} }) { this.formatSeparator = t.interpolation.formatSeparator || ','; const s = t.cacheInBuiltFormats ? gi : sl; this.formats = { number: s((i, r) => { const o = new Intl.NumberFormat(i, { ...r }); return a => o.format(a) }), currency: s((i, r) => { const o = new Intl.NumberFormat(i, { ...r, style: 'currency' }); return a => o.format(a) }), datetime: s((i, r) => { const o = new Intl.DateTimeFormat(i, { ...r }); return a => o.format(a) }), relativetime: s((i, r) => { const o = new Intl.RelativeTimeFormat(i, { ...r }); return a => o.format(a, r.range || 'day') }), list: s((i, r) => { const o = new Intl.ListFormat(i, { ...r }); return a => o.format(a) }) } }add(e, t) { this.formats[e.toLowerCase().trim()] = t }addCached(e, t) { this.formats[e.toLowerCase().trim()] = gi(t) }format(e, t, s, i = {}) {
    const r = t.split(this.formatSeparator); if (r.length > 1 && r[0].indexOf('(') > 1 && r[0].indexOf(')') < 0 && r.find(a => a.indexOf(')') > -1)) { const a = r.findIndex(l => l.indexOf(')') > -1); r[0] = [r[0], ...r.splice(1, a)].join(this.formatSeparator) } return r.reduce((a, l) => {
      var f; const { formatName: c, formatOptions: u } = nl(l); if (this.formats[c]) {
        let p = a; try { const h = ((f = i == null ? void 0 : i.formatParams) == null ? void 0 : f[i.interpolationkey]) || {}, d = h.locale || h.lng || i.locale || i.lng || s; p = this.formats[c](a, d, { ...u, ...i, ...h }) }
        catch (h) { this.logger.warn(h) } return p
      }
      else this.logger.warn(`there was no format function for ${c}`); return a
    }, e)
  }
} const rl = (n, e) => { n.pending[e] !== void 0 && (delete n.pending[e], n.pendingCount--) }; class ol extends bn {
  constructor(e, t, s, i = {}) { var r, o; super(), this.backend = e, this.store = t, this.services = s, this.languageUtils = s.languageUtils, this.options = i, this.logger = pe.create('backendConnector'), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], (o = (r = this.backend) == null ? void 0 : r.init) == null || o.call(r, s, i.backend, i) }queueLoad(e, t, s, i) { const r = {}, o = {}, a = {}, l = {}; return e.forEach((c) => { let u = !0; t.forEach((f) => { const p = `${c}|${f}`; !s.reload && this.store.hasResourceBundle(c, f) ? this.state[p] = 2 : this.state[p] < 0 || (this.state[p] === 1 ? o[p] === void 0 && (o[p] = !0) : (this.state[p] = 1, u = !1, o[p] === void 0 && (o[p] = !0), r[p] === void 0 && (r[p] = !0), l[f] === void 0 && (l[f] = !0))) }), u || (a[c] = !0) }), (Object.keys(r).length || Object.keys(o).length) && this.queue.push({ pending: o, pendingCount: Object.keys(o).length, loaded: {}, errors: [], callback: i }), { toLoad: Object.keys(r), pending: Object.keys(o), toLoadLanguages: Object.keys(a), toLoadNamespaces: Object.keys(l) } }loaded(e, t, s) { const i = e.split('|'), r = i[0], o = i[1]; t && this.emit('failedLoading', r, o, t), !t && s && this.store.addResourceBundle(r, o, s, void 0, void 0, { skipCopy: !0 }), this.state[e] = t ? -1 : 2, t && s && (this.state[e] = 0); const a = {}; this.queue.forEach((l) => { Wa(l.loaded, [r], o), rl(l, e), t && l.errors.push(t), l.pendingCount === 0 && !l.done && (Object.keys(l.loaded).forEach((c) => { a[c] || (a[c] = {}); const u = l.loaded[c]; u.length && u.forEach((f) => { a[c][f] === void 0 && (a[c][f] = !0) }) }), l.done = !0, l.errors.length ? l.callback(l.errors) : l.callback()) }), this.emit('loaded', a), this.queue = this.queue.filter(l => !l.done) }read(e, t, s, i = 0, r = this.retryTimeout, o) {
    if (!e.length) return o(null, {}); if (this.readingCalls >= this.maxParallelReads) { this.waitingReads.push({ lng: e, ns: t, fcName: s, tried: i, wait: r, callback: o }); return } this.readingCalls++; const a = (c, u) => { if (this.readingCalls--, this.waitingReads.length > 0) { const f = this.waitingReads.shift(); this.read(f.lng, f.ns, f.fcName, f.tried, f.wait, f.callback) } if (c && u && i < this.maxRetries) { setTimeout(() => { this.read.call(this, e, t, s, i + 1, r * 2, o) }, r); return }o(c, u) }, l = this.backend[s].bind(this.backend); if (l.length === 2) {
      try { const c = l(e, t); c && typeof c.then == 'function' ? c.then(u => a(null, u)).catch(a) : a(null, c) }
      catch (c) { a(c) } return
    } return l(e, t, a)
  }

  prepareLoading(e, t, s = {}, i) { if (!this.backend) return this.logger.warn('No backend was added via i18next.use. Will not load resources.'), i && i(); N(e) && (e = this.languageUtils.toResolveHierarchy(e)), N(t) && (t = [t]); const r = this.queueLoad(e, t, s, i); if (!r.toLoad.length) return r.pending.length || i(), null; r.toLoad.forEach((o) => { this.loadOne(o) }) }load(e, t, s) { this.prepareLoading(e, t, {}, s) }reload(e, t, s) { this.prepareLoading(e, t, { reload: !0 }, s) }loadOne(e, t = '') { const s = e.split('|'), i = s[0], r = s[1]; this.read(i, r, 'read', void 0, void 0, (o, a) => { o && this.logger.warn(`${t}loading namespace ${r} for language ${i} failed`, o), !o && a && this.logger.log(`${t}loaded namespace ${r} for language ${i}`, a), this.loaded(e, o, a) }) }saveMissing(e, t, s, i, r, o = {}, a = () => {}) {
    var l, c, u, f, p; if ((c = (l = this.services) == null ? void 0 : l.utils) != null && c.hasLoadedNamespace && !((f = (u = this.services) == null ? void 0 : u.utils) != null && f.hasLoadedNamespace(t))) { this.logger.warn(`did not save key "${s}" as the namespace "${t}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!'); return } if (!(s == null || s === '')) {
      if ((p = this.backend) != null && p.create) {
        const h = { ...o, isUpdate: r }, d = this.backend.create.bind(this.backend); if (d.length < 6) try { let _; d.length === 5 ? _ = d(e, t, s, i, h) : _ = d(e, t, s, i), _ && typeof _.then == 'function' ? _.then(y => a(null, y)).catch(a) : a(null, _) }
        catch (_) { a(_) } else d(e, t, s, i, a, h)
      }!e || !e[0] || this.store.addResource(e[0], t, s, i)
    }
  }
} const _i = () => ({ debug: !1, initAsync: !0, ns: ['translation'], defaultNS: ['translation'], fallbackLng: ['dev'], fallbackNS: !1, supportedLngs: !1, nonExplicitSupportedLngs: !1, load: 'all', preload: !1, simplifyPluralSuffix: !0, keySeparator: '.', nsSeparator: ':', pluralSeparator: '_', contextSeparator: '_', partialBundledLanguages: !1, saveMissing: !1, updateMissing: !1, saveMissingTo: 'fallback', saveMissingPlurals: !0, missingKeyHandler: !1, missingInterpolationHandler: !1, postProcess: !1, postProcessPassResolved: !1, returnNull: !1, returnEmptyString: !0, returnObjects: !1, joinArrays: !1, returnedObjectHandler: !1, parseMissingKeyHandler: !1, appendNamespaceToMissingKey: !1, appendNamespaceToCIMode: !1, overloadTranslationOptionHandler: (n) => { let e = {}; if (typeof n[1] == 'object' && (e = n[1]), N(n[1]) && (e.defaultValue = n[1]), N(n[2]) && (e.tDescription = n[2]), typeof n[2] == 'object' || typeof n[3] == 'object') { const t = n[3] || n[2]; Object.keys(t).forEach((s) => { e[s] = t[s] }) } return e }, interpolation: { escapeValue: !0, format: n => n, prefix: '{{', suffix: '}}', formatSeparator: ',', unescapePrefix: '-', nestingPrefix: '$t(', nestingSuffix: ')', nestingOptionsSeparator: ',', maxReplaces: 1e3, skipOnVariables: !0 }, cacheInBuiltFormats: !0 }), Ei = (n) => { var e, t; return N(n.ns) && (n.ns = [n.ns]), N(n.fallbackLng) && (n.fallbackLng = [n.fallbackLng]), N(n.fallbackNS) && (n.fallbackNS = [n.fallbackNS]), ((t = (e = n.supportedLngs) == null ? void 0 : e.indexOf) == null ? void 0 : t.call(e, 'cimode')) < 0 && (n.supportedLngs = n.supportedLngs.concat(['cimode'])), typeof n.initImmediate == 'boolean' && (n.initAsync = n.initImmediate), n }, Bt = () => {}, al = (n) => { Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach((t) => { typeof n[t] == 'function' && (n[t] = n[t].bind(n)) }) }; class xt extends bn {
  constructor(e = {}, t) { if (super(), this.options = Ei(e), this.services = {}, this.logger = pe, this.modules = { external: [] }, al(this), t && !this.isInitialized && !e.isClone) { if (!this.options.initAsync) return this.init(e, t), this; setTimeout(() => { this.init(e, t) }, 0) } }init(e = {}, t) { this.isInitializing = !0, typeof e == 'function' && (t = e, e = {}), e.defaultNS == null && e.ns && (N(e.ns) ? e.defaultNS = e.ns : e.ns.indexOf('translation') < 0 && (e.defaultNS = e.ns[0])); const s = _i(); this.options = { ...s, ...this.options, ...Ei(e) }, this.options.interpolation = { ...s.interpolation, ...this.options.interpolation }, e.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = e.keySeparator), e.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = e.nsSeparator); const i = c => c ? typeof c == 'function' ? new c() : c : null; if (!this.options.isClone) { this.modules.logger ? pe.init(i(this.modules.logger), this.options) : pe.init(null, this.options); let c; this.modules.formatter ? c = this.modules.formatter : c = il; const u = new di(this.options); this.store = new ci(this.options.resources, this.options); const f = this.services; f.logger = pe, f.resourceStore = this.store, f.languageUtils = u, f.pluralResolver = new el(u, { prepend: this.options.pluralSeparator, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), c && (!this.options.interpolation.format || this.options.interpolation.format === s.interpolation.format) && (f.formatter = i(c), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new tl(this.options), f.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, f.backendConnector = new ol(i(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on('*', (p, ...h) => { this.emit(p, ...h) }), this.modules.languageDetector && (f.languageDetector = i(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = i(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new fn(this.services, this.options), this.translator.on('*', (p, ...h) => { this.emit(p, ...h) }), this.modules.external.forEach((p) => { p.init && p.init(this) }) } if (this.format = this.options.interpolation.format, t || (t = Bt), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) { const c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); c.length > 0 && c[0] !== 'dev' && (this.options.lng = c[0]) }!this.services.languageDetector && !this.options.lng && this.logger.warn('init: no languageDetector is used and no lng is defined'), ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'].forEach((c) => { this[c] = (...u) => this.store[c](...u) }), ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'].forEach((c) => { this[c] = (...u) => (this.store[c](...u), this) }); const a = yt(), l = () => { const c = (u, f) => { this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn('init: i18next is already initialized. You should call init just once!'), this.isInitialized = !0, this.options.isClone || this.logger.log('initialized', this.options), this.emit('initialized', this.options), a.resolve(f), t(u, f) }; if (this.languages && !this.isInitialized) return c(null, this.t.bind(this)); this.changeLanguage(this.options.lng, c) }; return this.options.resources || !this.options.initAsync ? l() : setTimeout(l, 0), a }loadResources(e, t = Bt) {
    var r, o; let s = t; const i = N(e) ? e : this.language; if (typeof e == 'function' && (s = e), !this.options.resources || this.options.partialBundledLanguages) { if ((i == null ? void 0 : i.toLowerCase()) === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return s(); const a = [], l = (c) => { if (!c || c === 'cimode') return; this.services.languageUtils.toResolveHierarchy(c).forEach((f) => { f !== 'cimode' && a.indexOf(f) < 0 && a.push(f) }) }; i ? l(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(u => l(u)), (o = (r = this.options.preload) == null ? void 0 : r.forEach) == null || o.call(r, c => l(c)), this.services.backendConnector.load(a, this.options.ns, (c) => { !c && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), s(c) }) }
    else s(null)
  }

  reloadResources(e, t, s) { const i = yt(); return typeof e == 'function' && (s = e, e = void 0), typeof t == 'function' && (s = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), s || (s = Bt), this.services.backendConnector.reload(e, t, (r) => { i.resolve(), s(r) }), i }use(e) { if (!e) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()'); if (!e.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()'); return e.type === 'backend' && (this.modules.backend = e), (e.type === 'logger' || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === 'languageDetector' && (this.modules.languageDetector = e), e.type === 'i18nFormat' && (this.modules.i18nFormat = e), e.type === 'postProcessor' && Cr.addPostProcessor(e), e.type === 'formatter' && (this.modules.formatter = e), e.type === '3rdParty' && this.modules.external.push(e), this }setResolvedLanguage(e) { if (!(!e || !this.languages) && !(['cimode', 'dev'].indexOf(e) > -1)) { for (let t = 0; t < this.languages.length; t++) { const s = this.languages[t]; if (!(['cimode', 'dev'].indexOf(s) > -1) && this.store.hasLanguageSomeTranslations(s)) { this.resolvedLanguage = s; break } }!this.resolvedLanguage && this.languages.indexOf(e) < 0 && this.store.hasLanguageSomeTranslations(e) && (this.resolvedLanguage = e, this.languages.unshift(e)) } }changeLanguage(e, t) { this.isLanguageChangingTo = e; const s = yt(); this.emit('languageChanging', e); const i = (a) => { this.language = a, this.languages = this.services.languageUtils.toResolveHierarchy(a), this.resolvedLanguage = void 0, this.setResolvedLanguage(a) }, r = (a, l) => { l ? this.isLanguageChangingTo === e && (i(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit('languageChanged', l), this.logger.log('languageChanged', l)) : this.isLanguageChangingTo = void 0, s.resolve((...c) => this.t(...c)), t && t(a, (...c) => this.t(...c)) }, o = (a) => { var u, f; !e && !a && this.services.languageDetector && (a = []); const l = N(a) ? a : a && a[0], c = this.store.hasLanguageSomeTranslations(l) ? l : this.services.languageUtils.getBestMatchFromCodes(N(a) ? [a] : a); c && (this.language || i(c), this.translator.language || this.translator.changeLanguage(c), (f = (u = this.services.languageDetector) == null ? void 0 : u.cacheUserLanguage) == null || f.call(u, c)), this.loadResources(c, (p) => { r(p, c) }) }; return !e && this.services.languageDetector && !this.services.languageDetector.async ? o(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(o) : this.services.languageDetector.detect(o) : o(e), s }getFixedT(e, t, s) { const i = (r, o, ...a) => { let l; typeof o != 'object' ? l = this.options.overloadTranslationOptionHandler([r, o].concat(a)) : l = { ...o }, l.lng = l.lng || i.lng, l.lngs = l.lngs || i.lngs, l.ns = l.ns || i.ns, l.keyPrefix !== '' && (l.keyPrefix = l.keyPrefix || s || i.keyPrefix); const c = this.options.keySeparator || '.'; let u; return l.keyPrefix && Array.isArray(r) ? u = r.map(f => `${l.keyPrefix}${c}${f}`) : u = l.keyPrefix ? `${l.keyPrefix}${c}${r}` : r, this.t(u, l) }; return N(e) ? i.lng = e : i.lngs = e, i.ns = t, i.keyPrefix = s, i }t(...e) { var t; return (t = this.translator) == null ? void 0 : t.translate(...e) }exists(...e) { var t; return (t = this.translator) == null ? void 0 : t.exists(...e) }setDefaultNamespace(e) { this.options.defaultNS = e }hasLoadedNamespace(e, t = {}) { if (!this.isInitialized) return this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages), !1; const s = t.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, r = this.languages[this.languages.length - 1]; if (s.toLowerCase() === 'cimode') return !0; const o = (a, l) => { const c = this.services.backendConnector.state[`${a}|${l}`]; return c === -1 || c === 0 || c === 2 }; if (t.precheck) { const a = t.precheck(this, o); if (a !== void 0) return a } return !!(this.hasResourceBundle(s, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(s, e) && (!i || o(r, e))) }loadNamespaces(e, t) { const s = yt(); return this.options.ns ? (N(e) && (e = [e]), e.forEach((i) => { this.options.ns.indexOf(i) < 0 && this.options.ns.push(i) }), this.loadResources((i) => { s.resolve(), t && t(i) }), s) : (t && t(), Promise.resolve()) }loadLanguages(e, t) { const s = yt(); N(e) && (e = [e]); const i = this.options.preload || [], r = e.filter(o => i.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o)); return r.length ? (this.options.preload = i.concat(r), this.loadResources((o) => { s.resolve(), t && t(o) }), s) : (t && t(), Promise.resolve()) }dir(e) { var i, r; if (e || (e = this.resolvedLanguage || (((i = this.languages) == null ? void 0 : i.length) > 0 ? this.languages[0] : this.language)), !e) return 'rtl'; const t = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'], s = ((r = this.services) == null ? void 0 : r.languageUtils) || new di(_i()); return t.indexOf(s.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr' } static createInstance(e = {}, t) { return new xt(e, t) }cloneInstance(e = {}, t = Bt) { const s = e.forkResourceStore; s && delete e.forkResourceStore; const i = { ...this.options, ...e, isClone: !0 }, r = new xt(i); if ((e.debug !== void 0 || e.prefix !== void 0) && (r.logger = r.logger.clone(e)), ['store', 'services', 'language'].forEach((a) => { r[a] = this[a] }), r.services = { ...this.services }, r.services.utils = { hasLoadedNamespace: r.hasLoadedNamespace.bind(r) }, s) { const a = Object.keys(this.store.data).reduce((l, c) => (l[c] = { ...this.store.data[c] }, l[c] = Object.keys(l[c]).reduce((u, f) => (u[f] = { ...l[c][f] }, u), l[c]), l), {}); r.store = new ci(a, i), r.services.resourceStore = r.store } return r.translator = new fn(r.services, i), r.translator.on('*', (a, ...l) => { r.emit(a, ...l) }), r.init(i, t), r.translator.options = i, r.translator.backendConnector.services.utils = { hasLoadedNamespace: r.hasLoadedNamespace.bind(r) }, r }toJSON() { return { options: this.options, store: this.store, language: this.language, languages: this.languages, resolvedLanguage: this.resolvedLanguage } }
} const H = xt.createInstance(); H.createInstance = xt.createInstance; H.createInstance; H.dir; H.init; H.loadResources; H.reloadResources; H.use; H.changeLanguage; H.getFixedT; H.t; H.exists; H.setDefaultNamespace; H.hasLoadedNamespace; H.loadNamespaces; H.loadLanguages; const ll = { translation: { success: 'RSS  ', button: '', holder: ' RSS', empty: '   ', invalid: '    URL', networkErr: ' ', dubl: 'RSS  ', view: '', RssNull: '    RSS' } }; function xr(n, e) { return function () { return n.apply(e, arguments) } } const { toString: cl } = Object.prototype, { getPrototypeOf: Ss } = Object, { iterator: yn, toStringTag: Nr } = Symbol, vn = (n => (e) => { const t = cl.call(e); return n[t] || (n[t] = t.slice(8, -1).toLowerCase()) })(Object.create(null)), ae = n => (n = n.toLowerCase(), e => vn(e) === n), wn = n => e => typeof e === n, { isArray: ht } = Array, Nt = wn('undefined'); function ul(n) { return n !== null && !Nt(n) && n.constructor !== null && !Nt(n.constructor) && G(n.constructor.isBuffer) && n.constructor.isBuffer(n) } const $r = ae('ArrayBuffer'); function fl(n) { let e; return typeof ArrayBuffer < 'u' && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && $r(n.buffer), e } const dl = wn('string'), G = wn('function'), Lr = wn('number'), Sn = n => n !== null && typeof n == 'object', hl = n => n === !0 || n === !1, en = (n) => { if (vn(n) !== 'object') return !1; const e = Ss(n); return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Nr in n) && !(yn in n) }, pl = ae('Date'), ml = ae('File'), gl = ae('Blob'), _l = ae('FileList'), El = n => Sn(n) && G(n.pipe), bl = (n) => { let e; return n && (typeof FormData == 'function' && n instanceof FormData || G(n.append) && ((e = vn(n)) === 'formdata' || e === 'object' && G(n.toString) && n.toString() === '[object FormData]')) }, yl = ae('URLSearchParams'), [vl, wl, Sl, Tl] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(ae), Ol = n => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); function Dt(n, e, { allOwnKeys: t = !1 } = {}) { if (n === null || typeof n > 'u') return; let s, i; if (typeof n != 'object' && (n = [n]), ht(n)) for (s = 0, i = n.length; s < i; s++)e.call(null, n[s], s, n); else { const r = t ? Object.getOwnPropertyNames(n) : Object.keys(n), o = r.length; let a; for (s = 0; s < o; s++)a = r[s], e.call(null, n[a], a, n) } } function Dr(n, e) { e = e.toLowerCase(); const t = Object.keys(n); let s = t.length, i; for (;s-- > 0;) if (i = t[s], e === i.toLowerCase()) return i; return null } const je = typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : typeof window < 'u' ? window : global, Rr = n => !Nt(n) && n !== je; function as() { const { caseless: n } = Rr(this) && this || {}, e = {}, t = (s, i) => { const r = n && Dr(e, i) || i; en(e[r]) && en(s) ? e[r] = as(e[r], s) : en(s) ? e[r] = as({}, s) : ht(s) ? e[r] = s.slice() : e[r] = s }; for (let s = 0, i = arguments.length; s < i; s++)arguments[s] && Dt(arguments[s], t); return e } const Al = (n, e, t, { allOwnKeys: s } = {}) => (Dt(e, (i, r) => { t && G(i) ? n[r] = xr(i, t) : n[r] = i }, { allOwnKeys: s }), n), Cl = n => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n), xl = (n, e, t, s) => { n.prototype = Object.create(e.prototype, s), n.prototype.constructor = n, Object.defineProperty(n, 'super', { value: e.prototype }), t && Object.assign(n.prototype, t) }, Nl = (n, e, t, s) => { let i, r, o; const a = {}; if (e = e || {}, n == null) return e; do { for (i = Object.getOwnPropertyNames(n), r = i.length; r-- > 0;)o = i[r], (!s || s(o, n, e)) && !a[o] && (e[o] = n[o], a[o] = !0); n = t !== !1 && Ss(n) } while (n && (!t || t(n, e)) && n !== Object.prototype); return e }, $l = (n, e, t) => { n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length; const s = n.indexOf(e, t); return s !== -1 && s === t }, Ll = (n) => { if (!n) return null; if (ht(n)) return n; let e = n.length; if (!Lr(e)) return null; const t = new Array(e); for (;e-- > 0;)t[e] = n[e]; return t }, Dl = (n => e => n && e instanceof n)(typeof Uint8Array < 'u' && Ss(Uint8Array)), Rl = (n, e) => { const s = (n && n[yn]).call(n); let i; for (;(i = s.next()) && !i.done;) { const r = i.value; e.call(n, r[0], r[1]) } }, Pl = (n, e) => { let t; const s = []; for (;(t = n.exec(e)) !== null;)s.push(t); return s }, kl = ae('HTMLFormElement'), Il = n => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, s, i) { return s.toUpperCase() + i }), bi = (({ hasOwnProperty: n }) => (e, t) => n.call(e, t))(Object.prototype), Fl = ae('RegExp'), Pr = (n, e) => { const t = Object.getOwnPropertyDescriptors(n), s = {}; Dt(t, (i, r) => { let o; (o = e(i, r, n)) !== !1 && (s[r] = o || i) }), Object.defineProperties(n, s) }, Ml = (n) => { Pr(n, (e, t) => { if (G(n) && ['arguments', 'caller', 'callee'].indexOf(t) !== -1) return !1; const s = n[t]; if (G(s)) { if (e.enumerable = !1, 'writable' in e) { e.writable = !1; return }e.set || (e.set = () => { throw Error('Can not rewrite read-only method \'' + t + '\'') }) } }) }, Vl = (n, e) => { const t = {}, s = (i) => { i.forEach((r) => { t[r] = !0 }) }; return ht(n) ? s(n) : s(String(n).split(e)), t }, jl = () => {}, Hl = (n, e) => n != null && Number.isFinite(n = +n) ? n : e; function Ul(n) { return !!(n && G(n.append) && n[Nr] === 'FormData' && n[yn]) } const Bl = (n) => { const e = new Array(10), t = (s, i) => { if (Sn(s)) { if (e.indexOf(s) >= 0) return; if (!('toJSON' in s)) { e[i] = s; const r = ht(s) ? [] : {}; return Dt(s, (o, a) => { const l = t(o, i + 1); !Nt(l) && (r[a] = l) }), e[i] = void 0, r } } return s }; return t(n, 0) }, Kl = ae('AsyncFunction'), Wl = n => n && (Sn(n) || G(n)) && G(n.then) && G(n.catch), kr = ((n, e) => n ? setImmediate : e ? ((t, s) => (je.addEventListener('message', ({ source: i, data: r }) => { i === je && r === t && s.length && s.shift()() }, !1), (i) => { s.push(i), je.postMessage(t, '*') }))(`axios@${Math.random()}`, []) : t => setTimeout(t))(typeof setImmediate == 'function', G(je.postMessage)), zl = typeof queueMicrotask < 'u' ? queueMicrotask.bind(je) : typeof process < 'u' && process.nextTick || kr, ql = n => n != null && G(n[yn]), m = { isArray: ht, isArrayBuffer: $r, isBuffer: ul, isFormData: bl, isArrayBufferView: fl, isString: dl, isNumber: Lr, isBoolean: hl, isObject: Sn, isPlainObject: en, isReadableStream: vl, isRequest: wl, isResponse: Sl, isHeaders: Tl, isUndefined: Nt, isDate: pl, isFile: ml, isBlob: gl, isRegExp: Fl, isFunction: G, isStream: El, isURLSearchParams: yl, isTypedArray: Dl, isFileList: _l, forEach: Dt, merge: as, extend: Al, trim: Ol, stripBOM: Cl, inherits: xl, toFlatObject: Nl, kindOf: vn, kindOfTest: ae, endsWith: $l, toArray: Ll, forEachEntry: Rl, matchAll: Pl, isHTMLForm: kl, hasOwnProperty: bi, hasOwnProp: bi, reduceDescriptors: Pr, freezeMethods: Ml, toObjectSet: Vl, toCamelCase: Il, noop: jl, toFiniteNumber: Hl, findKey: Dr, global: je, isContextDefined: Rr, isSpecCompliantForm: Ul, toJSONObject: Bl, isAsyncFn: Kl, isThenable: Wl, setImmediate: kr, asap: zl, isIterable: ql }; function $(n, e, t, s, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = 'AxiosError', e && (this.code = e), t && (this.config = t), s && (this.request = s), i && (this.response = i, this.status = i.status ? i.status : null) }m.inherits($, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: m.toJSONObject(this.config), code: this.code, status: this.status } } }); const Ir = $.prototype, Fr = {}; ['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'].forEach((n) => { Fr[n] = { value: n } }); Object.defineProperties($, Fr); Object.defineProperty(Ir, 'isAxiosError', { value: !0 }); $.from = (n, e, t, s, i, r) => { const o = Object.create(Ir); return m.toFlatObject(n, o, function (l) { return l !== Error.prototype }, a => a !== 'isAxiosError'), $.call(o, n.message, e, t, s, i), o.cause = n, o.name = n.name, r && Object.assign(o, r), o }; const Yl = null; function ls(n) { return m.isPlainObject(n) || m.isArray(n) } function Mr(n) { return m.endsWith(n, '[]') ? n.slice(0, -2) : n } function yi(n, e, t) { return n ? n.concat(e).map(function (i, r) { return i = Mr(i), !t && r ? '[' + i + ']' : i }).join(t ? '.' : '') : e } function Gl(n) { return m.isArray(n) && !n.some(ls) } const Jl = m.toFlatObject(m, {}, null, function (e) { return /^is[A-Z]/.test(e) }); function Tn(n, e, t) { if (!m.isObject(n)) throw new TypeError('target must be an object'); e = e || new FormData(), t = m.toFlatObject(t, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (_, y) { return !m.isUndefined(y[_]) }); const s = t.metaTokens, i = t.visitor || u, r = t.dots, o = t.indexes, l = (t.Blob || typeof Blob < 'u' && Blob) && m.isSpecCompliantForm(e); if (!m.isFunction(i)) throw new TypeError('visitor must be a function'); function c(d) { if (d === null) return ''; if (m.isDate(d)) return d.toISOString(); if (m.isBoolean(d)) return d.toString(); if (!l && m.isBlob(d)) throw new $('Blob is not supported. Use a Buffer instead.'); return m.isArrayBuffer(d) || m.isTypedArray(d) ? l && typeof Blob == 'function' ? new Blob([d]) : Buffer.from(d) : d } function u(d, _, y) { let b = d; if (d && !y && typeof d == 'object') { if (m.endsWith(_, '{}'))_ = s ? _ : _.slice(0, -2), d = JSON.stringify(d); else if (m.isArray(d) && Gl(d) || (m.isFileList(d) || m.endsWith(_, '[]')) && (b = m.toArray(d))) return _ = Mr(_), b.forEach(function (g, E) { !(m.isUndefined(g) || g === null) && e.append(o === !0 ? yi([_], E, r) : o === null ? _ : _ + '[]', c(g)) }), !1 } return ls(d) ? !0 : (e.append(yi(y, _, r), c(d)), !1) } const f = [], p = Object.assign(Jl, { defaultVisitor: u, convertValue: c, isVisitable: ls }); function h(d, _) { if (!m.isUndefined(d)) { if (f.indexOf(d) !== -1) throw Error('Circular reference detected in ' + _.join('.')); f.push(d), m.forEach(d, function (b, T) { (!(m.isUndefined(b) || b === null) && i.call(e, b, m.isString(T) ? T.trim() : T, _, p)) === !0 && h(b, _ ? _.concat(T) : [T]) }), f.pop() } } if (!m.isObject(n)) throw new TypeError('data must be an object'); return h(n), e } function vi(n) { const e = { '!': '%21', '\'': '%27', '(': '%28', ')': '%29', '~': '%7E', '%20': '+', '%00': '\0' }; return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (s) { return e[s] }) } function Ts(n, e) { this._pairs = [], n && Tn(n, this, e) } const Vr = Ts.prototype; Vr.append = function (e, t) { this._pairs.push([e, t]) }; Vr.toString = function (e) { const t = e ? function (s) { return e.call(this, s, vi) } : vi; return this._pairs.map(function (i) { return t(i[0]) + '=' + t(i[1]) }, '').join('&') }; function Xl(n) { return encodeURIComponent(n).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']') } function jr(n, e, t) { if (!e) return n; const s = t && t.encode || Xl; m.isFunction(t) && (t = { serialize: t }); const i = t && t.serialize; let r; if (i ? r = i(e, t) : r = m.isURLSearchParams(e) ? e.toString() : new Ts(e, t).toString(s), r) { const o = n.indexOf('#'); o !== -1 && (n = n.slice(0, o)), n += (n.indexOf('?') === -1 ? '?' : '&') + r } return n } class wi {constructor() { this.handlers = [] }use(e, t, s) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: s ? s.synchronous : !1, runWhen: s ? s.runWhen : null }), this.handlers.length - 1 }eject(e) { this.handlers[e] && (this.handlers[e] = null) }clear() { this.handlers && (this.handlers = []) }forEach(e) { m.forEach(this.handlers, function (s) { s !== null && e(s) }) }} const Hr = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Ql = typeof URLSearchParams < 'u' ? URLSearchParams : Ts, Zl = typeof FormData < 'u' ? FormData : null, ec = typeof Blob < 'u' ? Blob : null, tc = { isBrowser: !0, classes: { URLSearchParams: Ql, FormData: Zl, Blob: ec }, protocols: ['http', 'https', 'file', 'blob', 'url', 'data'] }, Os = typeof window < 'u' && typeof document < 'u', cs = typeof navigator == 'object' && navigator || void 0, nc = Os && (!cs || ['ReactNative', 'NativeScript', 'NS'].indexOf(cs.product) < 0), sc = typeof WorkerGlobalScope < 'u' && self instanceof WorkerGlobalScope && typeof self.importScripts == 'function', ic = Os && window.location.href || 'http://localhost', rc = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Os, hasStandardBrowserEnv: nc, hasStandardBrowserWebWorkerEnv: sc, navigator: cs, origin: ic }, Symbol.toStringTag, { value: 'Module' })), j = { ...rc, ...tc }; function oc(n, e) { return Tn(n, new j.classes.URLSearchParams(), Object.assign({ visitor: function (t, s, i, r) { return j.isNode && m.isBuffer(t) ? (this.append(s, t.toString('base64')), !1) : r.defaultVisitor.apply(this, arguments) } }, e)) } function ac(n) { return m.matchAll(/\w+|\[(\w*)]/g, n).map(e => e[0] === '[]' ? '' : e[1] || e[0]) } function lc(n) { const e = {}, t = Object.keys(n); let s; const i = t.length; let r; for (s = 0; s < i; s++)r = t[s], e[r] = n[r]; return e } function Ur(n) { function e(t, s, i, r) { let o = t[r++]; if (o === '__proto__') return !0; const a = Number.isFinite(+o), l = r >= t.length; return o = !o && m.isArray(i) ? i.length : o, l ? (m.hasOwnProp(i, o) ? i[o] = [i[o], s] : i[o] = s, !a) : ((!i[o] || !m.isObject(i[o])) && (i[o] = []), e(t, s, i[o], r) && m.isArray(i[o]) && (i[o] = lc(i[o])), !a) } if (m.isFormData(n) && m.isFunction(n.entries)) { const t = {}; return m.forEachEntry(n, (s, i) => { e(ac(s), i, t, 0) }), t } return null } function cc(n, e, t) {
  if (m.isString(n)) try { return (e || JSON.parse)(n), m.trim(n) }
  catch (s) { if (s.name !== 'SyntaxError') throw s } return (t || JSON.stringify)(n)
} const Rt = { transitional: Hr, adapter: ['xhr', 'http', 'fetch'], transformRequest: [function (e, t) { const s = t.getContentType() || '', i = s.indexOf('application/json') > -1, r = m.isObject(e); if (r && m.isHTMLForm(e) && (e = new FormData(e)), m.isFormData(e)) return i ? JSON.stringify(Ur(e)) : e; if (m.isArrayBuffer(e) || m.isBuffer(e) || m.isStream(e) || m.isFile(e) || m.isBlob(e) || m.isReadableStream(e)) return e; if (m.isArrayBufferView(e)) return e.buffer; if (m.isURLSearchParams(e)) return t.setContentType('application/x-www-form-urlencoded;charset=utf-8', !1), e.toString(); let a; if (r) { if (s.indexOf('application/x-www-form-urlencoded') > -1) return oc(e, this.formSerializer).toString(); if ((a = m.isFileList(e)) || s.indexOf('multipart/form-data') > -1) { const l = this.env && this.env.FormData; return Tn(a ? { 'files[]': e } : e, l && new l(), this.formSerializer) } } return r || i ? (t.setContentType('application/json', !1), cc(e)) : e }], transformResponse: [function (e) {
  const t = this.transitional || Rt.transitional, s = t && t.forcedJSONParsing, i = this.responseType === 'json'; if (m.isResponse(e) || m.isReadableStream(e)) return e; if (e && m.isString(e) && (s && !this.responseType || i)) {
    const o = !(t && t.silentJSONParsing) && i; try { return JSON.parse(e) }
    catch (a) { if (o) throw a.name === 'SyntaxError' ? $.from(a, $.ERR_BAD_RESPONSE, this, null, this.response) : a }
  } return e
}], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, maxBodyLength: -1, env: { FormData: j.classes.FormData, Blob: j.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { 'Accept': 'application/json, text/plain, */*', 'Content-Type': void 0 } } }; m.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (n) => { Rt.headers[n] = {} }); const uc = m.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']), fc = (n) => {
    const e = {}; let t, s, i; return n && n.split(`
`).forEach(function (o) { i = o.indexOf(':'), t = o.substring(0, i).trim().toLowerCase(), s = o.substring(i + 1).trim(), !(!t || e[t] && uc[t]) && (t === 'set-cookie' ? e[t] ? e[t].push(s) : e[t] = [s] : e[t] = e[t] ? e[t] + ', ' + s : s) }), e
  }, Si = Symbol('internals'); function vt(n) { return n && String(n).trim().toLowerCase() } function tn(n) { return n === !1 || n == null ? n : m.isArray(n) ? n.map(tn) : String(n) } function dc(n) { const e = Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let s; for (;s = t.exec(n);)e[s[1]] = s[2]; return e } const hc = n => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim()); function jn(n, e, t, s, i) { if (m.isFunction(s)) return s.call(this, e, t); if (i && (e = t), !!m.isString(e)) { if (m.isString(s)) return e.indexOf(s) !== -1; if (m.isRegExp(s)) return s.test(e) } } function pc(n) { return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, s) => t.toUpperCase() + s) } function mc(n, e) { const t = m.toCamelCase(' ' + e); ['get', 'set', 'has'].forEach((s) => { Object.defineProperty(n, s + t, { value: function (i, r, o) { return this[s].call(this, e, i, r, o) }, configurable: !0 }) }) } let J = class {
  constructor(e) { e && this.set(e) }set(e, t, s) {
    const i = this; function r(a, l, c) { const u = vt(l); if (!u) throw new Error('header name must be a non-empty string'); const f = m.findKey(i, u); (!f || i[f] === void 0 || c === !0 || c === void 0 && i[f] !== !1) && (i[f || l] = tn(a)) } const o = (a, l) => m.forEach(a, (c, u) => r(c, u, l)); if (m.isPlainObject(e) || e instanceof this.constructor)o(e, t); else if (m.isString(e) && (e = e.trim()) && !hc(e))o(fc(e), t); else if (m.isObject(e) && m.isIterable(e)) { let a = {}, l, c; for (const u of e) { if (!m.isArray(u)) throw TypeError('Object iterator must return a key-value pair'); a[c = u[0]] = (l = a[c]) ? m.isArray(l) ? [...l, u[1]] : [l, u[1]] : u[1] }o(a, t) }
    else e != null && r(t, e, s); return this
  }

  get(e, t) { if (e = vt(e), e) { const s = m.findKey(this, e); if (s) { const i = this[s]; if (!t) return i; if (t === !0) return dc(i); if (m.isFunction(t)) return t.call(this, i, s); if (m.isRegExp(t)) return t.exec(i); throw new TypeError('parser must be boolean|regexp|function') } } }has(e, t) { if (e = vt(e), e) { const s = m.findKey(this, e); return !!(s && this[s] !== void 0 && (!t || jn(this, this[s], s, t))) } return !1 }delete(e, t) { const s = this; let i = !1; function r(o) { if (o = vt(o), o) { const a = m.findKey(s, o); a && (!t || jn(s, s[a], a, t)) && (delete s[a], i = !0) } } return m.isArray(e) ? e.forEach(r) : r(e), i }clear(e) { const t = Object.keys(this); let s = t.length, i = !1; for (;s--;) { const r = t[s]; (!e || jn(this, this[r], r, e, !0)) && (delete this[r], i = !0) } return i }normalize(e) { const t = this, s = {}; return m.forEach(this, (i, r) => { const o = m.findKey(s, r); if (o) { t[o] = tn(i), delete t[r]; return } const a = e ? pc(r) : String(r).trim(); a !== r && delete t[r], t[a] = tn(i), s[a] = !0 }), this }concat(...e) { return this.constructor.concat(this, ...e) }toJSON(e) { const t = Object.create(null); return m.forEach(this, (s, i) => { s != null && s !== !1 && (t[i] = e && m.isArray(s) ? s.join(', ') : s) }), t }[Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() }toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ': ' + t).join(`
`)
  }

  getSetCookie() { return this.get('set-cookie') || [] } get [Symbol.toStringTag]() { return 'AxiosHeaders' } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const s = new this(e); return t.forEach(i => s.set(i)), s } static accessor(e) { const s = (this[Si] = this[Si] = { accessors: {} }).accessors, i = this.prototype; function r(o) { const a = vt(o); s[a] || (mc(i, o), s[a] = !0) } return m.isArray(e) ? e.forEach(r) : r(e), this }
}; J.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']); m.reduceDescriptors(J.prototype, ({ value: n }, e) => { let t = e[0].toUpperCase() + e.slice(1); return { get: () => n, set(s) { this[t] = s } } }); m.freezeMethods(J); function Hn(n, e) { const t = this || Rt, s = e || t, i = J.from(s.headers); let r = s.data; return m.forEach(n, function (a) { r = a.call(t, r, i.normalize(), e ? e.status : void 0) }), i.normalize(), r } function Br(n) { return !!(n && n.__CANCEL__) } function pt(n, e, t) { $.call(this, n ?? 'canceled', $.ERR_CANCELED, e, t), this.name = 'CanceledError' }m.inherits(pt, $, { __CANCEL__: !0 }); function Kr(n, e, t) { const s = t.config.validateStatus; !t.status || !s || s(t.status) ? n(t) : e(new $('Request failed with status code ' + t.status, [$.ERR_BAD_REQUEST, $.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t)) } function gc(n) { const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n); return e && e[1] || '' } function _c(n, e) { n = n || 10; const t = new Array(n), s = new Array(n); let i = 0, r = 0, o; return e = e !== void 0 ? e : 1e3, function (l) { const c = Date.now(), u = s[r]; o || (o = c), t[i] = l, s[i] = c; let f = r, p = 0; for (;f !== i;)p += t[f++], f = f % n; if (i = (i + 1) % n, i === r && (r = (r + 1) % n), c - o < e) return; const h = u && c - u; return h ? Math.round(p * 1e3 / h) : void 0 } } function Ec(n, e) { let t = 0, s = 1e3 / e, i, r; const o = (c, u = Date.now()) => { t = u, i = null, r && (clearTimeout(r), r = null), n.apply(null, c) }; return [(...c) => { const u = Date.now(), f = u - t; f >= s ? o(c, u) : (i = c, r || (r = setTimeout(() => { r = null, o(i) }, s - f))) }, () => i && o(i)] } const dn = (n, e, t = 3) => { let s = 0; const i = _c(50, 250); return Ec((r) => { const o = r.loaded, a = r.lengthComputable ? r.total : void 0, l = o - s, c = i(l), u = o <= a; s = o; const f = { loaded: o, total: a, progress: a ? o / a : void 0, bytes: l, rate: c || void 0, estimated: c && a && u ? (a - o) / c : void 0, event: r, lengthComputable: a != null, [e ? 'download' : 'upload']: !0 }; n(f) }, t) }, Ti = (n, e) => { const t = n != null; return [s => e[0]({ lengthComputable: t, total: n, loaded: s }), e[1]] }, Oi = n => (...e) => m.asap(() => n(...e)), bc = j.hasStandardBrowserEnv ? ((n, e) => t => (t = new URL(t, j.origin), n.protocol === t.protocol && n.host === t.host && (e || n.port === t.port)))(new URL(j.origin), j.navigator && /(msie|trident)/i.test(j.navigator.userAgent)) : () => !0, yc = j.hasStandardBrowserEnv ? { write(n, e, t, s, i, r) { const o = [n + '=' + encodeURIComponent(e)]; m.isNumber(t) && o.push('expires=' + new Date(t).toGMTString()), m.isString(s) && o.push('path=' + s), m.isString(i) && o.push('domain=' + i), r === !0 && o.push('secure'), document.cookie = o.join('; ') }, read(n) { const e = document.cookie.match(new RegExp('(^|;\\s*)(' + n + ')=([^;]*)')); return e ? decodeURIComponent(e[3]) : null }, remove(n) { this.write(n, '', Date.now() - 864e5) } } : { write() {}, read() { return null }, remove() {} }; function vc(n) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n) } function wc(n, e) { return e ? n.replace(/\/?\/$/, '') + '/' + e.replace(/^\/+/, '') : n } function Wr(n, e, t) { let s = !vc(e); return n && (s || t == !1) ? wc(n, e) : e } const Ai = n => n instanceof J ? { ...n } : n; function We(n, e) {
  e = e || {}; const t = {}; function s(c, u, f, p) { return m.isPlainObject(c) && m.isPlainObject(u) ? m.merge.call({ caseless: p }, c, u) : m.isPlainObject(u) ? m.merge({}, u) : m.isArray(u) ? u.slice() : u } function i(c, u, f, p) {
    if (m.isUndefined(u)) { if (!m.isUndefined(c)) return s(void 0, c, f, p) }
    else return s(c, u, f, p)
  } function r(c, u) { if (!m.isUndefined(u)) return s(void 0, u) } function o(c, u) {
    if (m.isUndefined(u)) { if (!m.isUndefined(c)) return s(void 0, c) }
    else return s(void 0, u)
  } function a(c, u, f) { if (f in e) return s(c, u); if (f in n) return s(void 0, c) } const l = { url: r, method: r, data: r, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, withXSRFToken: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: a, headers: (c, u, f) => i(Ai(c), Ai(u), f, !0) }; return m.forEach(Object.keys(Object.assign({}, n, e)), function (u) { const f = l[u] || i, p = f(n[u], e[u], u); m.isUndefined(p) && f !== a || (t[u] = p) }), t
} const zr = (n) => { const e = We({}, n); let { data: t, withXSRFToken: s, xsrfHeaderName: i, xsrfCookieName: r, headers: o, auth: a } = e; e.headers = o = J.from(o), e.url = jr(Wr(e.baseURL, e.url, e.allowAbsoluteUrls), n.params, n.paramsSerializer), a && o.set('Authorization', 'Basic ' + btoa((a.username || '') + ':' + (a.password ? unescape(encodeURIComponent(a.password)) : ''))); let l; if (m.isFormData(t)) { if (j.hasStandardBrowserEnv || j.hasStandardBrowserWebWorkerEnv)o.setContentType(void 0); else if ((l = o.getContentType()) !== !1) { const [c, ...u] = l ? l.split(';').map(f => f.trim()).filter(Boolean) : []; o.setContentType([c || 'multipart/form-data', ...u].join('; ')) } } if (j.hasStandardBrowserEnv && (s && m.isFunction(s) && (s = s(e)), s || s !== !1 && bc(e.url))) { const c = i && r && yc.read(r); c && o.set(i, c) } return e }, Sc = typeof XMLHttpRequest < 'u', Tc = Sc && function (n) { return new Promise(function (t, s) { const i = zr(n); let r = i.data; const o = J.from(i.headers).normalize(); let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = i, u, f, p, h, d; function _() { h && h(), d && d(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener('abort', u) } let y = new XMLHttpRequest(); y.open(i.method.toUpperCase(), i.url, !0), y.timeout = i.timeout; function b() { if (!y) return; const g = J.from('getAllResponseHeaders' in y && y.getAllResponseHeaders()), v = { data: !a || a === 'text' || a === 'json' ? y.responseText : y.response, status: y.status, statusText: y.statusText, headers: g, config: n, request: y }; Kr(function (O) { t(O), _() }, function (O) { s(O), _() }, v), y = null }'onloadend' in y ? y.onloadend = b : y.onreadystatechange = function () { !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf('file:') === 0) || setTimeout(b) }, y.onabort = function () { y && (s(new $('Request aborted', $.ECONNABORTED, n, y)), y = null) }, y.onerror = function () { s(new $('Network Error', $.ERR_NETWORK, n, y)), y = null }, y.ontimeout = function () { let E = i.timeout ? 'timeout of ' + i.timeout + 'ms exceeded' : 'timeout exceeded'; const v = i.transitional || Hr; i.timeoutErrorMessage && (E = i.timeoutErrorMessage), s(new $(E, v.clarifyTimeoutError ? $.ETIMEDOUT : $.ECONNABORTED, n, y)), y = null }, r === void 0 && o.setContentType(null), 'setRequestHeader' in y && m.forEach(o.toJSON(), function (E, v) { y.setRequestHeader(v, E) }), m.isUndefined(i.withCredentials) || (y.withCredentials = !!i.withCredentials), a && a !== 'json' && (y.responseType = i.responseType), c && ([p, d] = dn(c, !0), y.addEventListener('progress', p)), l && y.upload && ([f, h] = dn(l), y.upload.addEventListener('progress', f), y.upload.addEventListener('loadend', h)), (i.cancelToken || i.signal) && (u = (g) => { y && (s(!g || g.type ? new pt(null, n, y) : g), y.abort(), y = null) }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener('abort', u))); const T = gc(i.url); if (T && j.protocols.indexOf(T) === -1) { s(new $('Unsupported protocol ' + T + ':', $.ERR_BAD_REQUEST, n)); return }y.send(r || null) }) }, Oc = (n, e) => { const { length: t } = n = n ? n.filter(Boolean) : []; if (e || t) { let s = new AbortController(), i; const r = function (c) { if (!i) { i = !0, a(); const u = c instanceof Error ? c : this.reason; s.abort(u instanceof $ ? u : new pt(u instanceof Error ? u.message : u)) } }; let o = e && setTimeout(() => { o = null, r(new $(`timeout ${e} of ms exceeded`, $.ETIMEDOUT)) }, e); const a = () => { n && (o && clearTimeout(o), o = null, n.forEach((c) => { c.unsubscribe ? c.unsubscribe(r) : c.removeEventListener('abort', r) }), n = null) }; n.forEach(c => c.addEventListener('abort', r)); const { signal: l } = s; return l.unsubscribe = () => m.asap(a), l } }, Ac = function* (n, e) { let t = n.byteLength; if (t < e) { yield n; return } let s = 0, i; for (;s < t;)i = s + e, yield n.slice(s, i), s = i }, Cc = async function* (n, e) { for await (const t of xc(n)) yield* Ac(t, e) }, xc = async function* (n) {
    if (n[Symbol.asyncIterator]) { yield* n; return } const e = n.getReader(); try { for (;;) { const { done: t, value: s } = await e.read(); if (t) break; yield s } }
    finally { await e.cancel() }
  }, Ci = (n, e, t, s) => {
    const i = Cc(n, e); let r = 0, o, a = (l) => { o || (o = !0, s && s(l)) }; return new ReadableStream({ async pull(l) {
      try { const { done: c, value: u } = await i.next(); if (c) { a(), l.close(); return } let f = u.byteLength; if (t) { let p = r += f; t(p) }l.enqueue(new Uint8Array(u)) }
      catch (c) { throw a(c), c }
    }, cancel(l) { return a(l), i.return() } }, { highWaterMark: 2 })
  }, On = typeof fetch == 'function' && typeof Request == 'function' && typeof Response == 'function', qr = On && typeof ReadableStream == 'function', Nc = On && (typeof TextEncoder == 'function' ? (n => e => n.encode(e))(new TextEncoder()) : async n => new Uint8Array(await new Response(n).arrayBuffer())), Yr = (n, ...e) => {
    try { return !!n(...e) }
    catch { return !1 }
  }, $c = qr && Yr(() => { let n = !1; const e = new Request(j.origin, { body: new ReadableStream(), method: 'POST', get duplex() { return n = !0, 'half' } }).headers.has('Content-Type'); return n && !e }), xi = 64 * 1024, us = qr && Yr(() => m.isReadableStream(new Response('').body)), hn = { stream: us && (n => n.body) }; On && ((n) => { ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach((e) => { !hn[e] && (hn[e] = m.isFunction(n[e]) ? t => t[e]() : (t, s) => { throw new $(`Response type '${e}' is not supported`, $.ERR_NOT_SUPPORT, s) }) }) })(new Response()); const Lc = async (n) => { if (n == null) return 0; if (m.isBlob(n)) return n.size; if (m.isSpecCompliantForm(n)) return (await new Request(j.origin, { method: 'POST', body: n }).arrayBuffer()).byteLength; if (m.isArrayBufferView(n) || m.isArrayBuffer(n)) return n.byteLength; if (m.isURLSearchParams(n) && (n = n + ''), m.isString(n)) return (await Nc(n)).byteLength }, Dc = async (n, e) => { const t = m.toFiniteNumber(n.getContentLength()); return t ?? Lc(e) }, Rc = On && (async (n) => {
    let { url: e, method: t, data: s, signal: i, cancelToken: r, timeout: o, onDownloadProgress: a, onUploadProgress: l, responseType: c, headers: u, withCredentials: f = 'same-origin', fetchOptions: p } = zr(n); c = c ? (c + '').toLowerCase() : 'text'; let h = Oc([i, r && r.toAbortSignal()], o), d; const _ = h && h.unsubscribe && (() => { h.unsubscribe() }); let y; try { if (l && $c && t !== 'get' && t !== 'head' && (y = await Dc(u, s)) !== 0) { let v = new Request(e, { method: 'POST', body: s, duplex: 'half' }), S; if (m.isFormData(s) && (S = v.headers.get('content-type')) && u.setContentType(S), v.body) { const [O, x] = Ti(y, dn(Oi(l))); s = Ci(v.body, xi, O, x) } }m.isString(f) || (f = f ? 'include' : 'omit'); const b = 'credentials' in Request.prototype; d = new Request(e, { ...p, signal: h, method: t.toUpperCase(), headers: u.normalize().toJSON(), body: s, duplex: 'half', credentials: b ? f : void 0 }); let T = await fetch(d, p); const g = us && (c === 'stream' || c === 'response'); if (us && (a || g && _)) { const v = {}; ['status', 'statusText', 'headers'].forEach((A) => { v[A] = T[A] }); const S = m.toFiniteNumber(T.headers.get('content-length')), [O, x] = a && Ti(S, dn(Oi(a), !0)) || []; T = new Response(Ci(T.body, xi, O, () => { x && x(), _ && _() }), v) }c = c || 'text'; let E = await hn[m.findKey(hn, c) || 'text'](T, n); return !g && _ && _(), await new Promise((v, S) => { Kr(v, S, { data: E, headers: J.from(T.headers), status: T.status, statusText: T.statusText, config: n, request: d }) }) }
    catch (b) { throw _ && _(), b && b.name === 'TypeError' && /Load failed|fetch/i.test(b.message) ? Object.assign(new $('Network Error', $.ERR_NETWORK, n, d), { cause: b.cause || b }) : $.from(b, b && b.code, n, d) }
  }), fs = { http: Yl, xhr: Tc, fetch: Rc }; m.forEach(fs, (n, e) => {
  if (n) {
    try { Object.defineProperty(n, 'name', { value: e }) }
    catch {}Object.defineProperty(n, 'adapterName', { value: e })
  }
}); const Ni = n => `- ${n}`, Pc = n => m.isFunction(n) || n === null || n === !1, Gr = { getAdapter: (n) => {
  n = m.isArray(n) ? n : [n]; const { length: e } = n; let t, s; const i = {}; for (let r = 0; r < e; r++) { t = n[r]; let o; if (s = t, !Pc(t) && (s = fs[(o = String(t)).toLowerCase()], s === void 0)) throw new $(`Unknown adapter '${o}'`); if (s) break; i[o || '#' + r] = s } if (!s) {
    const r = Object.entries(i).map(([a, l]) => `adapter ${a} ` + (l === !1 ? 'is not supported by the environment' : 'is not available in the build')); let o = e
      ? r.length > 1
        ? `since :
        ` + r.map(Ni).join(`
`)
        : ' ' + Ni(r[0])
      : 'as no adapter specified'; throw new $('There is no suitable adapter to dispatch the request ' + o, 'ERR_NOT_SUPPORT')
  } return s
}, adapters: fs }; function Un(n) { if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted) throw new pt(null, n) } function $i(n) { return Un(n), n.headers = J.from(n.headers), n.data = Hn.call(n, n.transformRequest), ['post', 'put', 'patch'].indexOf(n.method) !== -1 && n.headers.setContentType('application/x-www-form-urlencoded', !1), Gr.getAdapter(n.adapter || Rt.adapter)(n).then(function (s) { return Un(n), s.data = Hn.call(n, n.transformResponse, s), s.headers = J.from(s.headers), s }, function (s) { return Br(s) || (Un(n), s && s.response && (s.response.data = Hn.call(n, n.transformResponse, s.response), s.response.headers = J.from(s.response.headers))), Promise.reject(s) }) } const Jr = '1.10.0', An = {}; ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((n, e) => { An[n] = function (s) { return typeof s === n || 'a' + (e < 1 ? 'n ' : ' ') + n } }); const Li = {}; An.transitional = function (e, t, s) { function i(r, o) { return '[Axios v' + Jr + '] Transitional option \'' + r + '\'' + o + (s ? '. ' + s : '') } return (r, o, a) => { if (e === !1) throw new $(i(o, ' has been removed' + (t ? ' in ' + t : '')), $.ERR_DEPRECATED); return t && !Li[o] && (Li[o] = !0, console.warn(i(o, ' has been deprecated since v' + t + ' and will be removed in the near future'))), e ? e(r, o, a) : !0 } }; An.spelling = function (e) { return (t, s) => (console.warn(`${s} is likely a misspelling of ${e}`), !0) }; function kc(n, e, t) { if (typeof n != 'object') throw new $('options must be an object', $.ERR_BAD_OPTION_VALUE); const s = Object.keys(n); let i = s.length; for (;i-- > 0;) { const r = s[i], o = e[r]; if (o) { const a = n[r], l = a === void 0 || o(a, r, n); if (l !== !0) throw new $('option ' + r + ' must be ' + l, $.ERR_BAD_OPTION_VALUE); continue } if (t !== !0) throw new $('Unknown option ' + r, $.ERR_BAD_OPTION) } } const nn = { assertOptions: kc, validators: An }, de = nn.validators; let Be = class {
  constructor(e) { this.defaults = e || {}, this.interceptors = { request: new wi(), response: new wi() } } async request(e, t) {
    try { return await this._request(e, t) }
    catch (s) {
      if (s instanceof Error) {
        let i = {}; Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error(); const r = i.stack ? i.stack.replace(/^.+\n/, '') : ''; try {
          s.stack
            ? r && !String(s.stack).endsWith(r.replace(/^.+\n.+\n/, '')) && (s.stack += `
              ` + r)
            : s.stack = r
        }
        catch {}
      } throw s
    }
  }

  _request(e, t) {
    typeof e == 'string' ? (t = t || {}, t.url = e) : t = e || {}, t = We(this.defaults, t); const { transitional: s, paramsSerializer: i, headers: r } = t; s !== void 0 && nn.assertOptions(s, { silentJSONParsing: de.transitional(de.boolean), forcedJSONParsing: de.transitional(de.boolean), clarifyTimeoutError: de.transitional(de.boolean) }, !1), i != null && (m.isFunction(i) ? t.paramsSerializer = { serialize: i } : nn.assertOptions(i, { encode: de.function, serialize: de.function }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), nn.assertOptions(t, { baseUrl: de.spelling('baseURL'), withXsrfToken: de.spelling('withXSRFToken') }, !0), t.method = (t.method || this.defaults.method || 'get').toLowerCase(); let o = r && m.merge(r.common, r[t.method]); r && m.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], (d) => { delete r[d] }), t.headers = J.concat(o, r); const a = []; let l = !0; this.interceptors.request.forEach(function (_) { typeof _.runWhen == 'function' && _.runWhen(t) === !1 || (l = l && _.synchronous, a.unshift(_.fulfilled, _.rejected)) }); const c = []; this.interceptors.response.forEach(function (_) { c.push(_.fulfilled, _.rejected) }); let u, f = 0, p; if (!l) { const d = [$i.bind(this), void 0]; for (d.unshift.apply(d, a), d.push.apply(d, c), p = d.length, u = Promise.resolve(t); f < p;)u = u.then(d[f++], d[f++]); return u }p = a.length; let h = t; for (f = 0; f < p;) {
      const d = a[f++], _ = a[f++]; try { h = d(h) }
      catch (y) { _.call(this, y); break }
    } try { u = $i.call(this, h) }
    catch (d) { return Promise.reject(d) } for (f = 0, p = c.length; f < p;)u = u.then(c[f++], c[f++]); return u
  }

  getUri(e) { e = We(this.defaults, e); const t = Wr(e.baseURL, e.url, e.allowAbsoluteUrls); return jr(t, e.params, e.paramsSerializer) }
}; m.forEach(['delete', 'get', 'head', 'options'], function (e) { Be.prototype[e] = function (t, s) { return this.request(We(s || {}, { method: e, url: t, data: (s || {}).data })) } }); m.forEach(['post', 'put', 'patch'], function (e) { function t(s) { return function (r, o, a) { return this.request(We(a || {}, { method: e, headers: s ? { 'Content-Type': 'multipart/form-data' } : {}, url: r, data: o })) } }Be.prototype[e] = t(), Be.prototype[e + 'Form'] = t(!0) }); let Ic = class Xr {constructor(e) { if (typeof e != 'function') throw new TypeError('executor must be a function.'); let t; this.promise = new Promise(function (r) { t = r }); const s = this; this.promise.then((i) => { if (!s._listeners) return; let r = s._listeners.length; for (;r-- > 0;)s._listeners[r](i); s._listeners = null }), this.promise.then = (i) => { let r; const o = new Promise((a) => { s.subscribe(a), r = a }).then(i); return o.cancel = function () { s.unsubscribe(r) }, o }, e(function (r, o, a) { s.reason || (s.reason = new pt(r, o, a), t(s.reason)) }) }throwIfRequested() { if (this.reason) throw this.reason }subscribe(e) { if (this.reason) { e(this.reason); return } this._listeners ? this._listeners.push(e) : this._listeners = [e] }unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); t !== -1 && this._listeners.splice(t, 1) }toAbortSignal() { const e = new AbortController(), t = (s) => { e.abort(s) }; return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal } static source() { let e; return { token: new Xr(function (i) { e = i }), cancel: e } }}; function Fc(n) { return function (t) { return n.apply(null, t) } } function Mc(n) { return m.isObject(n) && n.isAxiosError === !0 } const ds = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(ds).forEach(([n, e]) => { ds[e] = n }); function Qr(n) { const e = new Be(n), t = xr(Be.prototype.request, e); return m.extend(t, Be.prototype, e, { allOwnKeys: !0 }), m.extend(t, e, null, { allOwnKeys: !0 }), t.create = function (i) { return Qr(We(n, i)) }, t } const M = Qr(Rt); M.Axios = Be; M.CanceledError = pt; M.CancelToken = Ic; M.isCancel = Br; M.VERSION = Jr; M.toFormData = Tn; M.AxiosError = $; M.Cancel = M.CanceledError; M.all = function (e) { return Promise.all(e) }; M.spread = Fc; M.isAxiosError = Mc; M.mergeConfig = We; M.AxiosHeaders = J; M.formToJSON = n => Ur(m.isHTMLForm(n) ? new FormData(n) : n); M.getAdapter = Gr.getAdapter; M.HttpStatusCode = ds; M.default = M; const { Axios: dm, AxiosError: hm, CanceledError: pm, isCancel: mm, CancelToken: gm, VERSION: _m, all: Em, Cancel: bm, isAxiosError: ym, spread: vm, toFormData: wm, AxiosHeaders: Sm, HttpStatusCode: Tm, formToJSON: Om, getAdapter: Am, mergeConfig: Cm } = M, Vc = async (n, e) => { const s = await M.create().get('https://allorigins.hexlet.app/get?url=' + n, { timeout: 3e3 }); if (s.status === 200) return s; throw new Error(e.t('networkErr')) }, jc = (n) => { const e = document.querySelector('#posts'), t = document.querySelector('#feeds'); if (t.hasChildNodes()) return; const s = document.createElement('ul'), i = document.createElement('ul'); i.classList.add('list-group', 'border-0', 'rounded-0'), s.id = 'postUl', s.classList.add('list-group', 'border-0', 'rounded-0'), e.prepend(s), t.prepend(i); const r = document.createElement('li'); r.classList.add('list-group-item', 'border-0', 'border-end-0'); const o = document.createElement('p'); o.classList.add('m-0', 'small', 'text-black-50'), o.textContent = n.description; const a = document.createElement('h3'); a.classList.add('h6', 'm-0'), a.textContent = n.feed, i.prepend(r), r.prepend(a), r.append(o) }; var B = 'top', Q = 'bottom', Z = 'right', K = 'left', Cn = 'auto', mt = [B, Q, Z, K], ze = 'start', at = 'end', Zr = 'clippingParents', As = 'viewport', nt = 'popper', eo = 'reference', hs = mt.reduce(function (n, e) { return n.concat([e + '-' + ze, e + '-' + at]) }, []), Cs = [].concat(mt, [Cn]).reduce(function (n, e) { return n.concat([e, e + '-' + ze, e + '-' + at]) }, []), to = 'beforeRead', no = 'read', so = 'afterRead', io = 'beforeMain', ro = 'main', oo = 'afterMain', ao = 'beforeWrite', lo = 'write', co = 'afterWrite', uo = [to, no, so, io, ro, oo, ao, lo, co]; function _e(n) { return n ? (n.nodeName || '').toLowerCase() : null } function ee(n) { if (n == null) return window; if (n.toString() !== '[object Window]') { var e = n.ownerDocument; return e && e.defaultView || window } return n } function qe(n) { var e = ee(n).Element; return n instanceof e || n instanceof Element } function ne(n) { var e = ee(n).HTMLElement; return n instanceof e || n instanceof HTMLElement } function xs(n) { if (typeof ShadowRoot > 'u') return !1; var e = ee(n).ShadowRoot; return n instanceof e || n instanceof ShadowRoot } function Hc(n) { var e = n.state; Object.keys(e.elements).forEach(function (t) { var s = e.styles[t] || {}, i = e.attributes[t] || {}, r = e.elements[t]; !ne(r) || !_e(r) || (Object.assign(r.style, s), Object.keys(i).forEach(function (o) { var a = i[o]; a === !1 ? r.removeAttribute(o) : r.setAttribute(o, a === !0 ? '' : a) })) }) } function Uc(n) { var e = n.state, t = { popper: { position: e.options.strategy, left: '0', top: '0', margin: '0' }, arrow: { position: 'absolute' }, reference: {} }; return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function () { Object.keys(e.elements).forEach(function (s) { var i = e.elements[s], r = e.attributes[s] || {}, o = Object.keys(e.styles.hasOwnProperty(s) ? e.styles[s] : t[s]), a = o.reduce(function (l, c) { return l[c] = '', l }, {}); !ne(i) || !_e(i) || (Object.assign(i.style, a), Object.keys(r).forEach(function (l) { i.removeAttribute(l) })) }) } } const Ns = { name: 'applyStyles', enabled: !0, phase: 'write', fn: Hc, effect: Uc, requires: ['computeStyles'] }; function me(n) { return n.split('-')[0] } var Ke = Math.max, pn = Math.min, lt = Math.round; function ps() { var n = navigator.userAgentData; return n != null && n.brands && Array.isArray(n.brands) ? n.brands.map(function (e) { return e.brand + '/' + e.version }).join(' ') : navigator.userAgent } function fo() { return !/^((?!chrome|android).)*safari/i.test(ps()) } function ct(n, e, t) { e === void 0 && (e = !1), t === void 0 && (t = !1); var s = n.getBoundingClientRect(), i = 1, r = 1; e && ne(n) && (i = n.offsetWidth > 0 && lt(s.width) / n.offsetWidth || 1, r = n.offsetHeight > 0 && lt(s.height) / n.offsetHeight || 1); var o = qe(n) ? ee(n) : window, a = o.visualViewport, l = !fo() && t, c = (s.left + (l && a ? a.offsetLeft : 0)) / i, u = (s.top + (l && a ? a.offsetTop : 0)) / r, f = s.width / i, p = s.height / r; return { width: f, height: p, top: u, right: c + f, bottom: u + p, left: c, x: c, y: u } } function $s(n) { var e = ct(n), t = n.offsetWidth, s = n.offsetHeight; return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - s) <= 1 && (s = e.height), { x: n.offsetLeft, y: n.offsetTop, width: t, height: s } } function ho(n, e) { var t = e.getRootNode && e.getRootNode(); if (n.contains(e)) return !0; if (t && xs(t)) { var s = e; do { if (s && n.isSameNode(s)) return !0; s = s.parentNode || s.host } while (s) } return !1 } function we(n) { return ee(n).getComputedStyle(n) } function Bc(n) { return ['table', 'td', 'th'].indexOf(_e(n)) >= 0 } function De(n) { return ((qe(n) ? n.ownerDocument : n.document) || window.document).documentElement } function xn(n) { return _e(n) === 'html' ? n : n.assignedSlot || n.parentNode || (xs(n) ? n.host : null) || De(n) } function Di(n) { return !ne(n) || we(n).position === 'fixed' ? null : n.offsetParent } function Kc(n) { var e = /firefox/i.test(ps()), t = /Trident/i.test(ps()); if (t && ne(n)) { var s = we(n); if (s.position === 'fixed') return null } var i = xn(n); for (xs(i) && (i = i.host); ne(i) && ['html', 'body'].indexOf(_e(i)) < 0;) { var r = we(i); if (r.transform !== 'none' || r.perspective !== 'none' || r.contain === 'paint' || ['transform', 'perspective'].indexOf(r.willChange) !== -1 || e && r.willChange === 'filter' || e && r.filter && r.filter !== 'none') return i; i = i.parentNode } return null } function Pt(n) { for (var e = ee(n), t = Di(n); t && Bc(t) && we(t).position === 'static';)t = Di(t); return t && (_e(t) === 'html' || _e(t) === 'body' && we(t).position === 'static') ? e : t || Kc(n) || e } function Ls(n) { return ['top', 'bottom'].indexOf(n) >= 0 ? 'x' : 'y' } function Ot(n, e, t) { return Ke(n, pn(e, t)) } function Wc(n, e, t) { var s = Ot(n, e, t); return s > t ? t : s } function po() { return { top: 0, right: 0, bottom: 0, left: 0 } } function mo(n) { return Object.assign({}, po(), n) } function go(n, e) { return e.reduce(function (t, s) { return t[s] = n, t }, {}) } var zc = function (e, t) { return e = typeof e == 'function' ? e(Object.assign({}, t.rects, { placement: t.placement })) : e, mo(typeof e != 'number' ? e : go(e, mt)) }; function qc(n) { var e, t = n.state, s = n.name, i = n.options, r = t.elements.arrow, o = t.modifiersData.popperOffsets, a = me(t.placement), l = Ls(a), c = [K, Z].indexOf(a) >= 0, u = c ? 'height' : 'width'; if (!(!r || !o)) { var f = zc(i.padding, t), p = $s(r), h = l === 'y' ? B : K, d = l === 'y' ? Q : Z, _ = t.rects.reference[u] + t.rects.reference[l] - o[l] - t.rects.popper[u], y = o[l] - t.rects.reference[l], b = Pt(r), T = b ? l === 'y' ? b.clientHeight || 0 : b.clientWidth || 0 : 0, g = _ / 2 - y / 2, E = f[h], v = T - p[u] - f[d], S = T / 2 - p[u] / 2 + g, O = Ot(E, S, v), x = l; t.modifiersData[s] = (e = {}, e[x] = O, e.centerOffset = O - S, e) } } function Yc(n) { var e = n.state, t = n.options, s = t.element, i = s === void 0 ? '[data-popper-arrow]' : s; i != null && (typeof i == 'string' && (i = e.elements.popper.querySelector(i), !i) || ho(e.elements.popper, i) && (e.elements.arrow = i)) } const _o = { name: 'arrow', enabled: !0, phase: 'main', fn: qc, effect: Yc, requires: ['popperOffsets'], requiresIfExists: ['preventOverflow'] }; function ut(n) { return n.split('-')[1] } var Gc = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }; function Jc(n, e) { var t = n.x, s = n.y, i = e.devicePixelRatio || 1; return { x: lt(t * i) / i || 0, y: lt(s * i) / i || 0 } } function Ri(n) { var e, t = n.popper, s = n.popperRect, i = n.placement, r = n.variation, o = n.offsets, a = n.position, l = n.gpuAcceleration, c = n.adaptive, u = n.roundOffsets, f = n.isFixed, p = o.x, h = p === void 0 ? 0 : p, d = o.y, _ = d === void 0 ? 0 : d, y = typeof u == 'function' ? u({ x: h, y: _ }) : { x: h, y: _ }; h = y.x, _ = y.y; var b = o.hasOwnProperty('x'), T = o.hasOwnProperty('y'), g = K, E = B, v = window; if (c) { var S = Pt(t), O = 'clientHeight', x = 'clientWidth'; if (S === ee(t) && (S = De(t), we(S).position !== 'static' && a === 'absolute' && (O = 'scrollHeight', x = 'scrollWidth')), S = S, i === B || (i === K || i === Z) && r === at) { E = Q; var A = f && S === v && v.visualViewport ? v.visualViewport.height : S[O]; _ -= A - s.height, _ *= l ? 1 : -1 } if (i === K || (i === B || i === Q) && r === at) { g = Z; var D = f && S === v && v.visualViewport ? v.visualViewport.width : S[x]; h -= D - s.width, h *= l ? 1 : -1 } } var L = Object.assign({ position: a }, c && Gc), P = u === !0 ? Jc({ x: h, y: _ }, ee(t)) : { x: h, y: _ }; if (h = P.x, _ = P.y, l) { var R; return Object.assign({}, L, (R = {}, R[E] = T ? '0' : '', R[g] = b ? '0' : '', R.transform = (v.devicePixelRatio || 1) <= 1 ? 'translate(' + h + 'px, ' + _ + 'px)' : 'translate3d(' + h + 'px, ' + _ + 'px, 0)', R)) } return Object.assign({}, L, (e = {}, e[E] = T ? _ + 'px' : '', e[g] = b ? h + 'px' : '', e.transform = '', e)) } function Xc(n) { var e = n.state, t = n.options, s = t.gpuAcceleration, i = s === void 0 ? !0 : s, r = t.adaptive, o = r === void 0 ? !0 : r, a = t.roundOffsets, l = a === void 0 ? !0 : a, c = { placement: me(e.placement), variation: ut(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: e.options.strategy === 'fixed' }; e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Ri(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Ri(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: 'absolute', adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { 'data-popper-placement': e.placement }) } const Ds = { name: 'computeStyles', enabled: !0, phase: 'beforeWrite', fn: Xc, data: {} }; var Kt = { passive: !0 }; function Qc(n) { var e = n.state, t = n.instance, s = n.options, i = s.scroll, r = i === void 0 ? !0 : i, o = s.resize, a = o === void 0 ? !0 : o, l = ee(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper); return r && c.forEach(function (u) { u.addEventListener('scroll', t.update, Kt) }), a && l.addEventListener('resize', t.update, Kt), function () { r && c.forEach(function (u) { u.removeEventListener('scroll', t.update, Kt) }), a && l.removeEventListener('resize', t.update, Kt) } } const Rs = { name: 'eventListeners', enabled: !0, phase: 'write', fn: function () {}, effect: Qc, data: {} }; var Zc = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; function sn(n) { return n.replace(/left|right|bottom|top/g, function (e) { return Zc[e] }) } var eu = { start: 'end', end: 'start' }; function Pi(n) { return n.replace(/start|end/g, function (e) { return eu[e] }) } function Ps(n) { var e = ee(n), t = e.pageXOffset, s = e.pageYOffset; return { scrollLeft: t, scrollTop: s } } function ks(n) { return ct(De(n)).left + Ps(n).scrollLeft } function tu(n, e) { var t = ee(n), s = De(n), i = t.visualViewport, r = s.clientWidth, o = s.clientHeight, a = 0, l = 0; if (i) { r = i.width, o = i.height; var c = fo(); (c || !c && e === 'fixed') && (a = i.offsetLeft, l = i.offsetTop) } return { width: r, height: o, x: a + ks(n), y: l } } function nu(n) { var e, t = De(n), s = Ps(n), i = (e = n.ownerDocument) == null ? void 0 : e.body, r = Ke(t.scrollWidth, t.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Ke(t.scrollHeight, t.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -s.scrollLeft + ks(n), l = -s.scrollTop; return we(i || t).direction === 'rtl' && (a += Ke(t.clientWidth, i ? i.clientWidth : 0) - r), { width: r, height: o, x: a, y: l } } function Is(n) { var e = we(n), t = e.overflow, s = e.overflowX, i = e.overflowY; return /auto|scroll|overlay|hidden/.test(t + i + s) } function Eo(n) { return ['html', 'body', '#document'].indexOf(_e(n)) >= 0 ? n.ownerDocument.body : ne(n) && Is(n) ? n : Eo(xn(n)) } function At(n, e) { var t; e === void 0 && (e = []); var s = Eo(n), i = s === ((t = n.ownerDocument) == null ? void 0 : t.body), r = ee(s), o = i ? [r].concat(r.visualViewport || [], Is(s) ? s : []) : s, a = e.concat(o); return i ? a : a.concat(At(xn(o))) } function ms(n) { return Object.assign({}, n, { left: n.x, top: n.y, right: n.x + n.width, bottom: n.y + n.height }) } function su(n, e) { var t = ct(n, !1, e === 'fixed'); return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t } function ki(n, e, t) { return e === As ? ms(tu(n, t)) : qe(e) ? su(e, t) : ms(nu(De(n))) } function iu(n) { var e = At(xn(n)), t = ['absolute', 'fixed'].indexOf(we(n).position) >= 0, s = t && ne(n) ? Pt(n) : n; return qe(s) ? e.filter(function (i) { return qe(i) && ho(i, s) && _e(i) !== 'body' }) : [] } function ru(n, e, t, s) { var i = e === 'clippingParents' ? iu(n) : [].concat(e), r = [].concat(i, [t]), o = r[0], a = r.reduce(function (l, c) { var u = ki(n, c, s); return l.top = Ke(u.top, l.top), l.right = pn(u.right, l.right), l.bottom = pn(u.bottom, l.bottom), l.left = Ke(u.left, l.left), l }, ki(n, o, s)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function bo(n) { var e = n.reference, t = n.element, s = n.placement, i = s ? me(s) : null, r = s ? ut(s) : null, o = e.x + e.width / 2 - t.width / 2, a = e.y + e.height / 2 - t.height / 2, l; switch (i) { case B:l = { x: o, y: e.y - t.height }; break; case Q:l = { x: o, y: e.y + e.height }; break; case Z:l = { x: e.x + e.width, y: a }; break; case K:l = { x: e.x - t.width, y: a }; break; default:l = { x: e.x, y: e.y } } var c = i ? Ls(i) : null; if (c != null) { var u = c === 'y' ? 'height' : 'width'; switch (r) { case ze:l[c] = l[c] - (e[u] / 2 - t[u] / 2); break; case at:l[c] = l[c] + (e[u] / 2 - t[u] / 2); break } } return l } function ft(n, e) { e === void 0 && (e = {}); var t = e, s = t.placement, i = s === void 0 ? n.placement : s, r = t.strategy, o = r === void 0 ? n.strategy : r, a = t.boundary, l = a === void 0 ? Zr : a, c = t.rootBoundary, u = c === void 0 ? As : c, f = t.elementContext, p = f === void 0 ? nt : f, h = t.altBoundary, d = h === void 0 ? !1 : h, _ = t.padding, y = _ === void 0 ? 0 : _, b = mo(typeof y != 'number' ? y : go(y, mt)), T = p === nt ? eo : nt, g = n.rects.popper, E = n.elements[d ? T : p], v = ru(qe(E) ? E : E.contextElement || De(n.elements.popper), l, u, o), S = ct(n.elements.reference), O = bo({ reference: S, element: g, placement: i }), x = ms(Object.assign({}, g, O)), A = p === nt ? x : S, D = { top: v.top - A.top + b.top, bottom: A.bottom - v.bottom + b.bottom, left: v.left - A.left + b.left, right: A.right - v.right + b.right }, L = n.modifiersData.offset; if (p === nt && L) { var P = L[i]; Object.keys(D).forEach(function (R) { var k = [Z, Q].indexOf(R) >= 0 ? 1 : -1, ce = [B, Q].indexOf(R) >= 0 ? 'y' : 'x'; D[R] += P[ce] * k }) } return D } function ou(n, e) { e === void 0 && (e = {}); var t = e, s = t.placement, i = t.boundary, r = t.rootBoundary, o = t.padding, a = t.flipVariations, l = t.allowedAutoPlacements, c = l === void 0 ? Cs : l, u = ut(s), f = u ? a ? hs : hs.filter(function (d) { return ut(d) === u }) : mt, p = f.filter(function (d) { return c.indexOf(d) >= 0 }); p.length === 0 && (p = f); var h = p.reduce(function (d, _) { return d[_] = ft(n, { placement: _, boundary: i, rootBoundary: r, padding: o })[me(_)], d }, {}); return Object.keys(h).sort(function (d, _) { return h[d] - h[_] }) } function au(n) { if (me(n) === Cn) return []; var e = sn(n); return [Pi(n), e, Pi(e)] } function lu(n) { var e = n.state, t = n.options, s = n.name; if (!e.modifiersData[s]._skip) { for (var i = t.mainAxis, r = i === void 0 ? !0 : i, o = t.altAxis, a = o === void 0 ? !0 : o, l = t.fallbackPlacements, c = t.padding, u = t.boundary, f = t.rootBoundary, p = t.altBoundary, h = t.flipVariations, d = h === void 0 ? !0 : h, _ = t.allowedAutoPlacements, y = e.options.placement, b = me(y), T = b === y, g = l || (T || !d ? [sn(y)] : au(y)), E = [y].concat(g).reduce(function (Ee, oe) { return Ee.concat(me(oe) === Cn ? ou(e, { placement: oe, boundary: u, rootBoundary: f, padding: c, flipVariations: d, allowedAutoPlacements: _ }) : oe) }, []), v = e.rects.reference, S = e.rects.popper, O = new Map(), x = !0, A = E[0], D = 0; D < E.length; D++) { var L = E[D], P = me(L), R = ut(L) === ze, k = [B, Q].indexOf(P) >= 0, ce = k ? 'width' : 'height', I = ft(e, { placement: L, boundary: u, rootBoundary: f, altBoundary: p, padding: c }), F = k ? R ? Z : K : R ? Q : B; v[ce] > S[ce] && (F = sn(F)); var ue = sn(F), te = []; if (r && te.push(I[P] <= 0), a && te.push(I[F] <= 0, I[ue] <= 0), te.every(function (Ee) { return Ee })) { A = L, x = !1; break }O.set(L, te) } if (x) for (var ke = d ? 3 : 1, V = function (oe) { var bt = E.find(function (Vt) { var Ie = O.get(Vt); if (Ie) return Ie.slice(0, oe).every(function (kn) { return kn }) }); if (bt) return A = bt, 'break' }, X = ke; X > 0; X--) { var fe = V(X); if (fe === 'break') break }e.placement !== A && (e.modifiersData[s]._skip = !0, e.placement = A, e.reset = !0) } } const yo = { name: 'flip', enabled: !0, phase: 'main', fn: lu, requiresIfExists: ['offset'], data: { _skip: !1 } }; function Ii(n, e, t) { return t === void 0 && (t = { x: 0, y: 0 }), { top: n.top - e.height - t.y, right: n.right - e.width + t.x, bottom: n.bottom - e.height + t.y, left: n.left - e.width - t.x } } function Fi(n) { return [B, Z, Q, K].some(function (e) { return n[e] >= 0 }) } function cu(n) { var e = n.state, t = n.name, s = e.rects.reference, i = e.rects.popper, r = e.modifiersData.preventOverflow, o = ft(e, { elementContext: 'reference' }), a = ft(e, { altBoundary: !0 }), l = Ii(o, s), c = Ii(a, i, r), u = Fi(l), f = Fi(c); e.modifiersData[t] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: f }, e.attributes.popper = Object.assign({}, e.attributes.popper, { 'data-popper-reference-hidden': u, 'data-popper-escaped': f }) } const vo = { name: 'hide', enabled: !0, phase: 'main', requiresIfExists: ['preventOverflow'], fn: cu }; function uu(n, e, t) { var s = me(n), i = [K, B].indexOf(s) >= 0 ? -1 : 1, r = typeof t == 'function' ? t(Object.assign({}, e, { placement: n })) : t, o = r[0], a = r[1]; return o = o || 0, a = (a || 0) * i, [K, Z].indexOf(s) >= 0 ? { x: a, y: o } : { x: o, y: a } } function fu(n) { var e = n.state, t = n.options, s = n.name, i = t.offset, r = i === void 0 ? [0, 0] : i, o = Cs.reduce(function (u, f) { return u[f] = uu(f, e.rects, r), u }, {}), a = o[e.placement], l = a.x, c = a.y; e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[s] = o } const wo = { name: 'offset', enabled: !0, phase: 'main', requires: ['popperOffsets'], fn: fu }; function du(n) { var e = n.state, t = n.name; e.modifiersData[t] = bo({ reference: e.rects.reference, element: e.rects.popper, placement: e.placement }) } const Fs = { name: 'popperOffsets', enabled: !0, phase: 'read', fn: du, data: {} }; function hu(n) { return n === 'x' ? 'y' : 'x' } function pu(n) { var e = n.state, t = n.options, s = n.name, i = t.mainAxis, r = i === void 0 ? !0 : i, o = t.altAxis, a = o === void 0 ? !1 : o, l = t.boundary, c = t.rootBoundary, u = t.altBoundary, f = t.padding, p = t.tether, h = p === void 0 ? !0 : p, d = t.tetherOffset, _ = d === void 0 ? 0 : d, y = ft(e, { boundary: l, rootBoundary: c, padding: f, altBoundary: u }), b = me(e.placement), T = ut(e.placement), g = !T, E = Ls(b), v = hu(E), S = e.modifiersData.popperOffsets, O = e.rects.reference, x = e.rects.popper, A = typeof _ == 'function' ? _(Object.assign({}, e.rects, { placement: e.placement })) : _, D = typeof A == 'number' ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), L = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, P = { x: 0, y: 0 }; if (S) { if (r) { var R, k = E === 'y' ? B : K, ce = E === 'y' ? Q : Z, I = E === 'y' ? 'height' : 'width', F = S[E], ue = F + y[k], te = F - y[ce], ke = h ? -x[I] / 2 : 0, V = T === ze ? O[I] : x[I], X = T === ze ? -x[I] : -O[I], fe = e.elements.arrow, Ee = h && fe ? $s(fe) : { width: 0, height: 0 }, oe = e.modifiersData['arrow#persistent'] ? e.modifiersData['arrow#persistent'].padding : po(), bt = oe[k], Vt = oe[ce], Ie = Ot(0, O[I], Ee[I]), kn = g ? O[I] / 2 - ke - Ie - bt - D.mainAxis : V - Ie - bt - D.mainAxis, la = g ? -O[I] / 2 + ke + Ie + Vt + D.mainAxis : X + Ie + Vt + D.mainAxis, In = e.elements.arrow && Pt(e.elements.arrow), ca = In ? E === 'y' ? In.clientTop || 0 : In.clientLeft || 0 : 0, zs = (R = L == null ? void 0 : L[E]) != null ? R : 0, ua = F + kn - zs - ca, fa = F + la - zs, qs = Ot(h ? pn(ue, ua) : ue, F, h ? Ke(te, fa) : te); S[E] = qs, P[E] = qs - F } if (a) { var Ys, da = E === 'x' ? B : K, ha = E === 'x' ? Q : Z, Fe = S[v], jt = v === 'y' ? 'height' : 'width', Gs = Fe + y[da], Js = Fe - y[ha], Fn = [B, K].indexOf(b) !== -1, Xs = (Ys = L == null ? void 0 : L[v]) != null ? Ys : 0, Qs = Fn ? Gs : Fe - O[jt] - x[jt] - Xs + D.altAxis, Zs = Fn ? Fe + O[jt] + x[jt] - Xs - D.altAxis : Js, ei = h && Fn ? Wc(Qs, Fe, Zs) : Ot(h ? Qs : Gs, Fe, h ? Zs : Js); S[v] = ei, P[v] = ei - Fe }e.modifiersData[s] = P } } const So = { name: 'preventOverflow', enabled: !0, phase: 'main', fn: pu, requiresIfExists: ['offset'] }; function mu(n) { return { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop } } function gu(n) { return n === ee(n) || !ne(n) ? Ps(n) : mu(n) } function _u(n) { var e = n.getBoundingClientRect(), t = lt(e.width) / n.offsetWidth || 1, s = lt(e.height) / n.offsetHeight || 1; return t !== 1 || s !== 1 } function Eu(n, e, t) { t === void 0 && (t = !1); var s = ne(e), i = ne(e) && _u(e), r = De(e), o = ct(n, i, t), a = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 }; return (s || !s && !t) && ((_e(e) !== 'body' || Is(r)) && (a = gu(e)), ne(e) ? (l = ct(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : r && (l.x = ks(r))), { x: o.left + a.scrollLeft - l.x, y: o.top + a.scrollTop - l.y, width: o.width, height: o.height } } function bu(n) { var e = new Map(), t = new Set(), s = []; n.forEach(function (r) { e.set(r.name, r) }); function i(r) { t.add(r.name); var o = [].concat(r.requires || [], r.requiresIfExists || []); o.forEach(function (a) { if (!t.has(a)) { var l = e.get(a); l && i(l) } }), s.push(r) } return n.forEach(function (r) { t.has(r.name) || i(r) }), s } function yu(n) { var e = bu(n); return uo.reduce(function (t, s) { return t.concat(e.filter(function (i) { return i.phase === s })) }, []) } function vu(n) { var e; return function () { return e || (e = new Promise(function (t) { Promise.resolve().then(function () { e = void 0, t(n()) }) })), e } } function wu(n) { var e = n.reduce(function (t, s) { var i = t[s.name]; return t[s.name] = i ? Object.assign({}, i, s, { options: Object.assign({}, i.options, s.options), data: Object.assign({}, i.data, s.data) }) : s, t }, {}); return Object.keys(e).map(function (t) { return e[t] }) } var Mi = { placement: 'bottom', modifiers: [], strategy: 'absolute' }; function Vi() { for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)e[t] = arguments[t]; return !e.some(function (s) { return !(s && typeof s.getBoundingClientRect == 'function') }) } function Nn(n) { n === void 0 && (n = {}); var e = n, t = e.defaultModifiers, s = t === void 0 ? [] : t, i = e.defaultOptions, r = i === void 0 ? Mi : i; return function (a, l, c) { c === void 0 && (c = r); var u = { placement: 'bottom', orderedModifiers: [], options: Object.assign({}, Mi, r), modifiersData: {}, elements: { reference: a, popper: l }, attributes: {}, styles: {} }, f = [], p = !1, h = { state: u, setOptions: function (b) { var T = typeof b == 'function' ? b(u.options) : b; _(), u.options = Object.assign({}, r, u.options, T), u.scrollParents = { reference: qe(a) ? At(a) : a.contextElement ? At(a.contextElement) : [], popper: At(l) }; var g = yu(wu([].concat(s, u.options.modifiers))); return u.orderedModifiers = g.filter(function (E) { return E.enabled }), d(), h.update() }, forceUpdate: function () { if (!p) { var b = u.elements, T = b.reference, g = b.popper; if (Vi(T, g)) { u.rects = { reference: Eu(T, Pt(g), u.options.strategy === 'fixed'), popper: $s(g) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function (D) { return u.modifiersData[D.name] = Object.assign({}, D.data) }); for (var E = 0; E < u.orderedModifiers.length; E++) { if (u.reset === !0) { u.reset = !1, E = -1; continue } var v = u.orderedModifiers[E], S = v.fn, O = v.options, x = O === void 0 ? {} : O, A = v.name; typeof S == 'function' && (u = S({ state: u, options: x, name: A, instance: h }) || u) } } } }, update: vu(function () { return new Promise(function (y) { h.forceUpdate(), y(u) }) }), destroy: function () { _(), p = !0 } }; if (!Vi(a, l)) return h; h.setOptions(c).then(function (y) { !p && c.onFirstUpdate && c.onFirstUpdate(y) }); function d() { u.orderedModifiers.forEach(function (y) { var b = y.name, T = y.options, g = T === void 0 ? {} : T, E = y.effect; if (typeof E == 'function') { var v = E({ state: u, name: b, instance: h, options: g }), S = function () {}; f.push(v || S) } }) } function _() { f.forEach(function (y) { return y() }), f = [] } return h } } var Su = Nn(), Tu = [Rs, Fs, Ds, Ns], Ou = Nn({ defaultModifiers: Tu }), Au = [Rs, Fs, Ds, Ns, wo, yo, So, _o, vo], Ms = Nn({ defaultModifiers: Au }); const To = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: oo, afterRead: so, afterWrite: co, applyStyles: Ns, arrow: _o, auto: Cn, basePlacements: mt, beforeMain: io, beforeRead: to, beforeWrite: ao, bottom: Q, clippingParents: Zr, computeStyles: Ds, createPopper: Ms, createPopperBase: Su, createPopperLite: Ou, detectOverflow: ft, end: at, eventListeners: Rs, flip: yo, hide: vo, left: K, main: ro, modifierPhases: uo, offset: wo, placements: Cs, popper: nt, popperGenerator: Nn, popperOffsets: Fs, preventOverflow: So, read: no, reference: eo, right: Z, start: ze, top: B, variationPlacements: hs, viewport: As, write: lo }, Symbol.toStringTag, { value: 'Module' }))/*!
  * Bootstrap v5.3.6 (https://getbootstrap.com/)
  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */const Te = new Map(), Bn = { set(n, e, t) { Te.has(n) || Te.set(n, new Map()); const s = Te.get(n); if (!s.has(e) && s.size !== 0) { console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`); return }s.set(e, t) }, get(n, e) { return Te.has(n) && Te.get(n).get(e) || null }, remove(n, e) { if (!Te.has(n)) return; const t = Te.get(n); t.delete(e), t.size === 0 && Te.delete(n) } }, Cu = 1e6, xu = 1e3, gs = 'transitionend', Oo = n => (n && window.CSS && window.CSS.escape && (n = n.replace(/#([^\s"#']+)/g, (e, t) => `#${CSS.escape(t)}`)), n), Nu = n => n == null ? `${n}` : Object.prototype.toString.call(n).match(/\s([a-z]+)/i)[1].toLowerCase(), $u = (n) => { do n += Math.floor(Math.random() * Cu); while (document.getElementById(n)); return n }, Lu = (n) => { if (!n) return 0; let { transitionDuration: e, transitionDelay: t } = window.getComputedStyle(n); const s = Number.parseFloat(e), i = Number.parseFloat(t); return !s && !i ? 0 : (e = e.split(',')[0], t = t.split(',')[0], (Number.parseFloat(e) + Number.parseFloat(t)) * xu) }, Ao = (n) => { n.dispatchEvent(new Event(gs)) }, ye = n => !n || typeof n != 'object' ? !1 : (typeof n.jquery < 'u' && (n = n[0]), typeof n.nodeType < 'u'), xe = n => ye(n) ? n.jquery ? n[0] : n : typeof n == 'string' && n.length > 0 ? document.querySelector(Oo(n)) : null, gt = (n) => { if (!ye(n) || n.getClientRects().length === 0) return !1; const e = getComputedStyle(n).getPropertyValue('visibility') === 'visible', t = n.closest('details:not([open])'); if (!t) return e; if (t !== n) { const s = n.closest('summary'); if (s && s.parentNode !== t || s === null) return !1 } return e }, Ne = n => !n || n.nodeType !== Node.ELEMENT_NODE || n.classList.contains('disabled') ? !0 : typeof n.disabled < 'u' ? n.disabled : n.hasAttribute('disabled') && n.getAttribute('disabled') !== 'false', Co = (n) => { if (!document.documentElement.attachShadow) return null; if (typeof n.getRootNode == 'function') { const e = n.getRootNode(); return e instanceof ShadowRoot ? e : null } return n instanceof ShadowRoot ? n : n.parentNode ? Co(n.parentNode) : null }, mn = () => {}, kt = (n) => { n.offsetHeight }, xo = () => window.jQuery && !document.body.hasAttribute('data-bs-no-jquery') ? window.jQuery : null, Kn = [], Du = (n) => { document.readyState === 'loading' ? (Kn.length || document.addEventListener('DOMContentLoaded', () => { for (const e of Kn)e() }), Kn.push(n)) : n() }, se = () => document.documentElement.dir === 'rtl', re = (n) => { Du(() => { const e = xo(); if (e) { const t = n.NAME, s = e.fn[t]; e.fn[t] = n.jQueryInterface, e.fn[t].Constructor = n, e.fn[t].noConflict = () => (e.fn[t] = s, n.jQueryInterface) } }) }, Y = (n, e = [], t = n) => typeof n == 'function' ? n.call(...e) : t, No = (n, e, t = !0) => { if (!t) { Y(n); return } const i = Lu(e) + 5; let r = !1; const o = ({ target: a }) => { a === e && (r = !0, e.removeEventListener(gs, o), Y(n)) }; e.addEventListener(gs, o), setTimeout(() => { r || Ao(e) }, i) }, Vs = (n, e, t, s) => { const i = n.length; let r = n.indexOf(e); return r === -1 ? !t && s ? n[i - 1] : n[0] : (r += t ? 1 : -1, s && (r = (r + i) % i), n[Math.max(0, Math.min(r, i - 1))]) }, Ru = /[^.]*(?=\..*)\.|.*/, Pu = /\..*/, ku = /::\d+$/, Wn = {}; let ji = 1; const $o = { mouseenter: 'mouseover', mouseleave: 'mouseout' }, Iu = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']); function Lo(n, e) { return e && `${e}::${ji++}` || n.uidEvent || ji++ } function Do(n) { const e = Lo(n); return n.uidEvent = e, Wn[e] = Wn[e] || {}, Wn[e] } function Fu(n, e) { return function t(s) { return js(s, { delegateTarget: n }), t.oneOff && w.off(n, s.type, e), e.apply(n, [s]) } } function Mu(n, e, t) { return function s(i) { const r = n.querySelectorAll(e); for (let { target: o } = i; o && o !== this; o = o.parentNode) for (const a of r) if (a === o) return js(i, { delegateTarget: o }), s.oneOff && w.off(n, i.type, e, t), t.apply(o, [i]) } } function Ro(n, e, t = null) { return Object.values(n).find(s => s.callable === e && s.delegationSelector === t) } function Po(n, e, t) { const s = typeof e == 'string', i = s ? t : e || t; let r = ko(n); return Iu.has(r) || (r = n), [s, i, r] } function Hi(n, e, t, s, i) { if (typeof e != 'string' || !n) return; let [r, o, a] = Po(e, t, s); e in $o && (o = (d => function (_) { if (!_.relatedTarget || _.relatedTarget !== _.delegateTarget && !_.delegateTarget.contains(_.relatedTarget)) return d.call(this, _) })(o)); const l = Do(n), c = l[a] || (l[a] = {}), u = Ro(c, o, r ? t : null); if (u) { u.oneOff = u.oneOff && i; return } const f = Lo(o, e.replace(Ru, '')), p = r ? Mu(n, t, o) : Fu(n, o); p.delegationSelector = r ? t : null, p.callable = o, p.oneOff = i, p.uidEvent = f, c[f] = p, n.addEventListener(a, p, r) } function _s(n, e, t, s, i) { const r = Ro(e[t], s, i); r && (n.removeEventListener(t, r, !!i), delete e[t][r.uidEvent]) } function Vu(n, e, t, s) { const i = e[t] || {}; for (const [r, o] of Object.entries(i))r.includes(s) && _s(n, e, t, o.callable, o.delegationSelector) } function ko(n) { return n = n.replace(Pu, ''), $o[n] || n } const w = { on(n, e, t, s) { Hi(n, e, t, s, !1) }, one(n, e, t, s) { Hi(n, e, t, s, !0) }, off(n, e, t, s) { if (typeof e != 'string' || !n) return; const [i, r, o] = Po(e, t, s), a = o !== e, l = Do(n), c = l[o] || {}, u = e.startsWith('.'); if (typeof r < 'u') { if (!Object.keys(c).length) return; _s(n, l, o, r, i ? t : null); return } if (u) for (const f of Object.keys(l))Vu(n, l, f, e.slice(1)); for (const [f, p] of Object.entries(c)) { const h = f.replace(ku, ''); (!a || e.includes(h)) && _s(n, l, o, p.callable, p.delegationSelector) } }, trigger(n, e, t) { if (typeof e != 'string' || !n) return null; const s = xo(), i = ko(e), r = e !== i; let o = null, a = !0, l = !0, c = !1; r && s && (o = s.Event(e, t), s(n).trigger(o), a = !o.isPropagationStopped(), l = !o.isImmediatePropagationStopped(), c = o.isDefaultPrevented()); const u = js(new Event(e, { bubbles: a, cancelable: !0 }), t); return c && u.preventDefault(), l && n.dispatchEvent(u), u.defaultPrevented && o && o.preventDefault(), u } }; function js(n, e = {}) {
  for (const [t, s] of Object.entries(e)) try { n[t] = s }
  catch { Object.defineProperty(n, t, { configurable: !0, get() { return s } }) } return n
} function Ui(n) {
  if (n === 'true') return !0; if (n === 'false') return !1; if (n === Number(n).toString()) return Number(n); if (n === '' || n === 'null') return null; if (typeof n != 'string') return n; try { return JSON.parse(decodeURIComponent(n)) }
  catch { return n }
} function zn(n) { return n.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`) } const ve = { setDataAttribute(n, e, t) { n.setAttribute(`data-bs-${zn(e)}`, t) }, removeDataAttribute(n, e) { n.removeAttribute(`data-bs-${zn(e)}`) }, getDataAttributes(n) { if (!n) return {}; const e = {}, t = Object.keys(n.dataset).filter(s => s.startsWith('bs') && !s.startsWith('bsConfig')); for (const s of t) { let i = s.replace(/^bs/, ''); i = i.charAt(0).toLowerCase() + i.slice(1), e[i] = Ui(n.dataset[s]) } return e }, getDataAttribute(n, e) { return Ui(n.getAttribute(`data-bs-${zn(e)}`)) } }; class It {static get Default() { return {} } static get DefaultType() { return {} } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') }_getConfig(e) { return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e }_configAfterMerge(e) { return e }_mergeConfigObj(e, t) { const s = ye(t) ? ve.getDataAttribute(t, 'config') : {}; return { ...this.constructor.Default, ...typeof s == 'object' ? s : {}, ...ye(t) ? ve.getDataAttributes(t) : {}, ...typeof e == 'object' ? e : {} } }_typeCheckConfig(e, t = this.constructor.DefaultType) { for (const [s, i] of Object.entries(t)) { const r = e[s], o = ye(r) ? 'element' : Nu(r); if (!new RegExp(i).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${i}".`) } }} const ju = '5.3.6'; class le extends It {constructor(e, t) { super(), e = xe(e), e && (this._element = e, this._config = this._getConfig(t), Bn.set(this._element, this.constructor.DATA_KEY, this)) }dispose() { Bn.remove(this._element, this.constructor.DATA_KEY), w.off(this._element, this.constructor.EVENT_KEY); for (const e of Object.getOwnPropertyNames(this)) this[e] = null }_queueCallback(e, t, s = !0) { No(e, t, s) }_getConfig(e) { return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } static getInstance(e) { return Bn.get(xe(e), this.DATA_KEY) } static getOrCreateInstance(e, t = {}) { return this.getInstance(e) || new this(e, typeof t == 'object' ? t : null) } static get VERSION() { return ju } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } static eventName(e) { return `${e}${this.EVENT_KEY}` }} const qn = (n) => { let e = n.getAttribute('data-bs-target'); if (!e || e === '#') { let t = n.getAttribute('href'); if (!t || !t.includes('#') && !t.startsWith('.')) return null; t.includes('#') && !t.startsWith('#') && (t = `#${t.split('#')[1]}`), e = t && t !== '#' ? t.trim() : null } return e ? e.split(',').map(t => Oo(t)).join(',') : null }, C = { find(n, e = document.documentElement) { return [].concat(...Element.prototype.querySelectorAll.call(e, n)) }, findOne(n, e = document.documentElement) { return Element.prototype.querySelector.call(e, n) }, children(n, e) { return [].concat(...n.children).filter(t => t.matches(e)) }, parents(n, e) { const t = []; let s = n.parentNode.closest(e); for (;s;)t.push(s), s = s.parentNode.closest(e); return t }, prev(n, e) { let t = n.previousElementSibling; for (;t;) { if (t.matches(e)) return [t]; t = t.previousElementSibling } return [] }, next(n, e) { let t = n.nextElementSibling; for (;t;) { if (t.matches(e)) return [t]; t = t.nextElementSibling } return [] }, focusableChildren(n) { const e = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(t => `${t}:not([tabindex^="-"])`).join(','); return this.find(e, n).filter(t => !Ne(t) && gt(t)) }, getSelectorFromElement(n) { const e = qn(n); return e && C.findOne(e) ? e : null }, getElementFromSelector(n) { const e = qn(n); return e ? C.findOne(e) : null }, getMultipleElementsFromSelector(n) { const e = qn(n); return e ? C.find(e) : [] } }, $n = (n, e = 'hide') => { const t = `click.dismiss${n.EVENT_KEY}`, s = n.NAME; w.on(document, t, `[data-bs-dismiss="${s}"]`, function (i) { if (['A', 'AREA'].includes(this.tagName) && i.preventDefault(), Ne(this)) return; const r = C.getElementFromSelector(this) || this.closest(`.${s}`); n.getOrCreateInstance(r)[e]() }) }, Hu = 'alert', Uu = 'bs.alert', Io = `.${Uu}`, Bu = `close${Io}`, Ku = `closed${Io}`, Wu = 'fade', zu = 'show'; class Ln extends le {static get NAME() { return Hu }close() { if (w.trigger(this._element, Bu).defaultPrevented) return; this._element.classList.remove(zu); const t = this._element.classList.contains(Wu); this._queueCallback(() => this._destroyElement(), this._element, t) }_destroyElement() { this._element.remove(), w.trigger(this._element, Ku), this.dispose() } static jQueryInterface(e) { return this.each(function () { const t = Ln.getOrCreateInstance(this); if (typeof e == 'string') { if (t[e] === void 0 || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}$n(Ln, 'close'); re(Ln); const qu = 'button', Yu = 'bs.button', Gu = `.${Yu}`, Ju = '.data-api', Xu = 'active', Bi = '[data-bs-toggle="button"]', Qu = `click${Gu}${Ju}`; class Dn extends le {static get NAME() { return qu }toggle() { this._element.setAttribute('aria-pressed', this._element.classList.toggle(Xu)) } static jQueryInterface(e) { return this.each(function () { const t = Dn.getOrCreateInstance(this); e === 'toggle' && t[e]() }) }}w.on(document, Qu, Bi, (n) => { n.preventDefault(); const e = n.target.closest(Bi); Dn.getOrCreateInstance(e).toggle() }); re(Dn); const Zu = 'swipe', _t = '.bs.swipe', ef = `touchstart${_t}`, tf = `touchmove${_t}`, nf = `touchend${_t}`, sf = `pointerdown${_t}`, rf = `pointerup${_t}`, of = 'touch', af = 'pen', lf = 'pointer-event', cf = 40, uf = { endCallback: null, leftCallback: null, rightCallback: null }, ff = { endCallback: '(function|null)', leftCallback: '(function|null)', rightCallback: '(function|null)' }; class gn extends It {constructor(e, t) { super(), this._element = e, !(!e || !gn.isSupported()) && (this._config = this._getConfig(t), this._deltaX = 0, this._supportPointerEvents = !!window.PointerEvent, this._initEvents()) } static get Default() { return uf } static get DefaultType() { return ff } static get NAME() { return Zu }dispose() { w.off(this._element, _t) }_start(e) { if (!this._supportPointerEvents) { this._deltaX = e.touches[0].clientX; return } this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) }_end(e) { this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), Y(this._config.endCallback) }_move(e) { this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX }_handleSwipe() { const e = Math.abs(this._deltaX); if (e <= cf) return; const t = e / this._deltaX; this._deltaX = 0, t && Y(t > 0 ? this._config.rightCallback : this._config.leftCallback) }_initEvents() { this._supportPointerEvents ? (w.on(this._element, sf, e => this._start(e)), w.on(this._element, rf, e => this._end(e)), this._element.classList.add(lf)) : (w.on(this._element, ef, e => this._start(e)), w.on(this._element, tf, e => this._move(e)), w.on(this._element, nf, e => this._end(e))) }_eventIsPointerPenTouch(e) { return this._supportPointerEvents && (e.pointerType === af || e.pointerType === of) } static isSupported() { return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0 }} const df = 'carousel', hf = 'bs.carousel', Re = `.${hf}`, Fo = '.data-api', pf = 'ArrowLeft', mf = 'ArrowRight', gf = 500, wt = 'next', Ze = 'prev', st = 'left', rn = 'right', _f = `slide${Re}`, Yn = `slid${Re}`, Ef = `keydown${Re}`, bf = `mouseenter${Re}`, yf = `mouseleave${Re}`, vf = `dragstart${Re}`, wf = `load${Re}${Fo}`, Sf = `click${Re}${Fo}`, Mo = 'carousel', Wt = 'active', Tf = 'slide', Of = 'carousel-item-end', Af = 'carousel-item-start', Cf = 'carousel-item-next', xf = 'carousel-item-prev', Vo = '.active', jo = '.carousel-item', Nf = Vo + jo, $f = '.carousel-item img', Lf = '.carousel-indicators', Df = '[data-bs-slide], [data-bs-slide-to]', Rf = '[data-bs-ride="carousel"]', Pf = { [pf]: rn, [mf]: st }, kf = { interval: 5e3, keyboard: !0, pause: 'hover', ride: !1, touch: !0, wrap: !0 }, If = { interval: '(number|boolean)', keyboard: 'boolean', pause: '(string|boolean)', ride: '(boolean|string)', touch: 'boolean', wrap: 'boolean' }; class Ft extends le {constructor(e, t) { super(e, t), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = C.findOne(Lf, this._element), this._addEventListeners(), this._config.ride === Mo && this.cycle() } static get Default() { return kf } static get DefaultType() { return If } static get NAME() { return df }next() { this._slide(wt) }nextWhenVisible() { !document.hidden && gt(this._element) && this.next() }prev() { this._slide(Ze) }pause() { this._isSliding && Ao(this._element), this._clearInterval() }cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval) }_maybeEnableCycle() { if (this._config.ride) { if (this._isSliding) { w.one(this._element, Yn, () => this.cycle()); return } this.cycle() } }to(e) { const t = this._getItems(); if (e > t.length - 1 || e < 0) return; if (this._isSliding) { w.one(this._element, Yn, () => this.to(e)); return } const s = this._getItemIndex(this._getActive()); if (s === e) return; const i = e > s ? wt : Ze; this._slide(i, t[e]) }dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() }_configAfterMerge(e) { return e.defaultInterval = e.interval, e }_addEventListeners() { this._config.keyboard && w.on(this._element, Ef, e => this._keydown(e)), this._config.pause === 'hover' && (w.on(this._element, bf, () => this.pause()), w.on(this._element, yf, () => this._maybeEnableCycle())), this._config.touch && gn.isSupported() && this._addTouchEventListeners() }_addTouchEventListeners() { for (const s of C.find($f, this._element))w.on(s, vf, i => i.preventDefault()); const t = { leftCallback: () => this._slide(this._directionToOrder(st)), rightCallback: () => this._slide(this._directionToOrder(rn)), endCallback: () => { this._config.pause === 'hover' && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), gf + this._config.interval)) } }; this._swipeHelper = new gn(this._element, t) }_keydown(e) { if (/input|textarea/i.test(e.target.tagName)) return; const t = Pf[e.key]; t && (e.preventDefault(), this._slide(this._directionToOrder(t))) }_getItemIndex(e) { return this._getItems().indexOf(e) }_setActiveIndicatorElement(e) { if (!this._indicatorsElement) return; const t = C.findOne(Vo, this._indicatorsElement); t.classList.remove(Wt), t.removeAttribute('aria-current'); const s = C.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement); s && (s.classList.add(Wt), s.setAttribute('aria-current', 'true')) }_updateInterval() { const e = this._activeElement || this._getActive(); if (!e) return; const t = Number.parseInt(e.getAttribute('data-bs-interval'), 10); this._config.interval = t || this._config.defaultInterval }_slide(e, t = null) { if (this._isSliding) return; const s = this._getActive(), i = e === wt, r = t || Vs(this._getItems(), s, i, this._config.wrap); if (r === s) return; const o = this._getItemIndex(r), a = h => w.trigger(this._element, h, { relatedTarget: r, direction: this._orderToDirection(e), from: this._getItemIndex(s), to: o }); if (a(_f).defaultPrevented || !s || !r) return; const c = !!this._interval; this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = r; const u = i ? Af : Of, f = i ? Cf : xf; r.classList.add(f), kt(r), s.classList.add(u), r.classList.add(u); const p = () => { r.classList.remove(u, f), r.classList.add(Wt), s.classList.remove(Wt, f, u), this._isSliding = !1, a(Yn) }; this._queueCallback(p, s, this._isAnimated()), c && this.cycle() }_isAnimated() { return this._element.classList.contains(Tf) }_getActive() { return C.findOne(Nf, this._element) }_getItems() { return C.find(jo, this._element) }_clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null) }_directionToOrder(e) { return se() ? e === st ? Ze : wt : e === st ? wt : Ze }_orderToDirection(e) { return se() ? e === Ze ? st : rn : e === Ze ? rn : st } static jQueryInterface(e) { return this.each(function () { const t = Ft.getOrCreateInstance(this, e); if (typeof e == 'number') { t.to(e); return } if (typeof e == 'string') { if (t[e] === void 0 || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}w.on(document, Sf, Df, function (n) { const e = C.getElementFromSelector(this); if (!e || !e.classList.contains(Mo)) return; n.preventDefault(); const t = Ft.getOrCreateInstance(e), s = this.getAttribute('data-bs-slide-to'); if (s) { t.to(s), t._maybeEnableCycle(); return } if (ve.getDataAttribute(this, 'slide') === 'next') { t.next(), t._maybeEnableCycle(); return }t.prev(), t._maybeEnableCycle() }); w.on(window, wf, () => { const n = C.find(Rf); for (const e of n)Ft.getOrCreateInstance(e) }); re(Ft); const Ff = 'collapse', Mf = 'bs.collapse', Mt = `.${Mf}`, Vf = '.data-api', jf = `show${Mt}`, Hf = `shown${Mt}`, Uf = `hide${Mt}`, Bf = `hidden${Mt}`, Kf = `click${Mt}${Vf}`, Gn = 'show', ot = 'collapse', zt = 'collapsing', Wf = 'collapsed', zf = `:scope .${ot} .${ot}`, qf = 'collapse-horizontal', Yf = 'width', Gf = 'height', Jf = '.collapse.show, .collapse.collapsing', Es = '[data-bs-toggle="collapse"]', Xf = { parent: null, toggle: !0 }, Qf = { parent: '(null|element)', toggle: 'boolean' }; class $t extends le {constructor(e, t) { super(e, t), this._isTransitioning = !1, this._triggerArray = []; const s = C.find(Es); for (const i of s) { const r = C.getSelectorFromElement(i), o = C.find(r).filter(a => a === this._element); r !== null && o.length && this._triggerArray.push(i) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return Xf } static get DefaultType() { return Qf } static get NAME() { return Ff }toggle() { this._isShown() ? this.hide() : this.show() }show() { if (this._isTransitioning || this._isShown()) return; let e = []; if (this._config.parent && (e = this._getFirstLevelChildren(Jf).filter(a => a !== this._element).map(a => $t.getOrCreateInstance(a, { toggle: !1 }))), e.length && e[0]._isTransitioning || w.trigger(this._element, jf).defaultPrevented) return; for (const a of e)a.hide(); const s = this._getDimension(); this._element.classList.remove(ot), this._element.classList.add(zt), this._element.style[s] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const i = () => { this._isTransitioning = !1, this._element.classList.remove(zt), this._element.classList.add(ot, Gn), this._element.style[s] = '', w.trigger(this._element, Hf) }, o = `scroll${s[0].toUpperCase() + s.slice(1)}`; this._queueCallback(i, this._element, !0), this._element.style[s] = `${this._element[o]}px` }hide() { if (this._isTransitioning || !this._isShown() || w.trigger(this._element, Uf).defaultPrevented) return; const t = this._getDimension(); this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, kt(this._element), this._element.classList.add(zt), this._element.classList.remove(ot, Gn); for (const i of this._triggerArray) { const r = C.getElementFromSelector(i); r && !this._isShown(r) && this._addAriaAndCollapsedClass([i], !1) } this._isTransitioning = !0; const s = () => { this._isTransitioning = !1, this._element.classList.remove(zt), this._element.classList.add(ot), w.trigger(this._element, Bf) }; this._element.style[t] = '', this._queueCallback(s, this._element, !0) }_isShown(e = this._element) { return e.classList.contains(Gn) }_configAfterMerge(e) { return e.toggle = !!e.toggle, e.parent = xe(e.parent), e }_getDimension() { return this._element.classList.contains(qf) ? Yf : Gf }_initializeChildren() { if (!this._config.parent) return; const e = this._getFirstLevelChildren(Es); for (const t of e) { const s = C.getElementFromSelector(t); s && this._addAriaAndCollapsedClass([t], this._isShown(s)) } }_getFirstLevelChildren(e) { const t = C.find(zf, this._config.parent); return C.find(e, this._config.parent).filter(s => !t.includes(s)) }_addAriaAndCollapsedClass(e, t) { if (e.length) for (const s of e)s.classList.toggle(Wf, !t), s.setAttribute('aria-expanded', t) } static jQueryInterface(e) { const t = {}; return typeof e == 'string' && /show|hide/.test(e) && (t.toggle = !1), this.each(function () { const s = $t.getOrCreateInstance(this, t); if (typeof e == 'string') { if (typeof s[e] > 'u') throw new TypeError(`No method named "${e}"`); s[e]() } }) }}w.on(document, Kf, Es, function (n) { (n.target.tagName === 'A' || n.delegateTarget && n.delegateTarget.tagName === 'A') && n.preventDefault(); for (const e of C.getMultipleElementsFromSelector(this))$t.getOrCreateInstance(e, { toggle: !1 }).toggle() }); re($t); const Ki = 'dropdown', Zf = 'bs.dropdown', Ge = `.${Zf}`, Hs = '.data-api', ed = 'Escape', Wi = 'Tab', td = 'ArrowUp', zi = 'ArrowDown', nd = 2, sd = `hide${Ge}`, id = `hidden${Ge}`, rd = `show${Ge}`, od = `shown${Ge}`, Ho = `click${Ge}${Hs}`, Uo = `keydown${Ge}${Hs}`, ad = `keyup${Ge}${Hs}`, it = 'show', ld = 'dropup', cd = 'dropend', ud = 'dropstart', fd = 'dropup-center', dd = 'dropdown-center', He = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', hd = `${He}.${it}`, on = '.dropdown-menu', pd = '.navbar', md = '.navbar-nav', gd = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)', _d = se() ? 'top-end' : 'top-start', Ed = se() ? 'top-start' : 'top-end', bd = se() ? 'bottom-end' : 'bottom-start', yd = se() ? 'bottom-start' : 'bottom-end', vd = se() ? 'left-start' : 'right-start', wd = se() ? 'right-start' : 'left-start', Sd = 'top', Td = 'bottom', Od = { autoClose: !0, boundary: 'clippingParents', display: 'dynamic', offset: [0, 2], popperConfig: null, reference: 'toggle' }, Ad = { autoClose: '(boolean|string)', boundary: '(string|element)', display: 'string', offset: '(array|string|function)', popperConfig: '(null|object|function)', reference: '(string|element|object)' }; class ge extends le {constructor(e, t) { super(e, t), this._popper = null, this._parent = this._element.parentNode, this._menu = C.next(this._element, on)[0] || C.prev(this._element, on)[0] || C.findOne(on, this._parent), this._inNavbar = this._detectNavbar() } static get Default() { return Od } static get DefaultType() { return Ad } static get NAME() { return Ki }toggle() { return this._isShown() ? this.hide() : this.show() }show() { if (Ne(this._element) || this._isShown()) return; const e = { relatedTarget: this._element }; if (!w.trigger(this._element, rd, e).defaultPrevented) { if (this._createPopper(), 'ontouchstart' in document.documentElement && !this._parent.closest(md)) for (const s of [].concat(...document.body.children))w.on(s, 'mouseover', mn); this._element.focus(), this._element.setAttribute('aria-expanded', !0), this._menu.classList.add(it), this._element.classList.add(it), w.trigger(this._element, od, e) } }hide() { if (Ne(this._element) || !this._isShown()) return; const e = { relatedTarget: this._element }; this._completeHide(e) }dispose() { this._popper && this._popper.destroy(), super.dispose() }update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() }_completeHide(e) { if (!w.trigger(this._element, sd, e).defaultPrevented) { if ('ontouchstart' in document.documentElement) for (const s of [].concat(...document.body.children))w.off(s, 'mouseover', mn); this._popper && this._popper.destroy(), this._menu.classList.remove(it), this._element.classList.remove(it), this._element.setAttribute('aria-expanded', 'false'), ve.removeDataAttribute(this._menu, 'popper'), w.trigger(this._element, id, e), this._element.focus() } }_getConfig(e) { if (e = super._getConfig(e), typeof e.reference == 'object' && !ye(e.reference) && typeof e.reference.getBoundingClientRect != 'function') throw new TypeError(`${Ki.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return e }_createPopper() { if (typeof To > 'u') throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org/docs/v2/)'); let e = this._element; this._config.reference === 'parent' ? e = this._parent : ye(this._config.reference) ? e = xe(this._config.reference) : typeof this._config.reference == 'object' && (e = this._config.reference); const t = this._getPopperConfig(); this._popper = Ms(e, this._menu, t) }_isShown() { return this._menu.classList.contains(it) }_getPlacement() { const e = this._parent; if (e.classList.contains(cd)) return vd; if (e.classList.contains(ud)) return wd; if (e.classList.contains(fd)) return Sd; if (e.classList.contains(dd)) return Td; const t = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end'; return e.classList.contains(ld) ? t ? Ed : _d : t ? yd : bd }_detectNavbar() { return this._element.closest(pd) !== null }_getOffset() { const { offset: e } = this._config; return typeof e == 'string' ? e.split(',').map(t => Number.parseInt(t, 10)) : typeof e == 'function' ? t => e(t, this._element) : e }_getPopperConfig() { const e = { placement: this._getPlacement(), modifiers: [{ name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'offset', options: { offset: this._getOffset() } }] }; return (this._inNavbar || this._config.display === 'static') && (ve.setDataAttribute(this._menu, 'popper', 'static'), e.modifiers = [{ name: 'applyStyles', enabled: !1 }]), { ...e, ...Y(this._config.popperConfig, [void 0, e]) } }_selectMenuItem({ key: e, target: t }) { const s = C.find(gd, this._menu).filter(i => gt(i)); s.length && Vs(s, t, e === zi, !s.includes(t)).focus() } static jQueryInterface(e) { return this.each(function () { const t = ge.getOrCreateInstance(this, e); if (typeof e == 'string') { if (typeof t[e] > 'u') throw new TypeError(`No method named "${e}"`); t[e]() } }) } static clearMenus(e) { if (e.button === nd || e.type === 'keyup' && e.key !== Wi) return; const t = C.find(hd); for (const s of t) { const i = ge.getInstance(s); if (!i || i._config.autoClose === !1) continue; const r = e.composedPath(), o = r.includes(i._menu); if (r.includes(i._element) || i._config.autoClose === 'inside' && !o || i._config.autoClose === 'outside' && o || i._menu.contains(e.target) && (e.type === 'keyup' && e.key === Wi || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; const a = { relatedTarget: i._element }; e.type === 'click' && (a.clickEvent = e), i._completeHide(a) } } static dataApiKeydownHandler(e) { const t = /input|textarea/i.test(e.target.tagName), s = e.key === ed, i = [td, zi].includes(e.key); if (!i && !s || t && !s) return; e.preventDefault(); const r = this.matches(He) ? this : C.prev(this, He)[0] || C.next(this, He)[0] || C.findOne(He, e.delegateTarget.parentNode), o = ge.getOrCreateInstance(r); if (i) { e.stopPropagation(), o.show(), o._selectMenuItem(e); return }o._isShown() && (e.stopPropagation(), o.hide(), r.focus()) }}w.on(document, Uo, He, ge.dataApiKeydownHandler); w.on(document, Uo, on, ge.dataApiKeydownHandler); w.on(document, Ho, ge.clearMenus); w.on(document, ad, ge.clearMenus); w.on(document, Ho, He, function (n) { n.preventDefault(), ge.getOrCreateInstance(this).toggle() }); re(ge); const Bo = 'backdrop', Cd = 'fade', qi = 'show', Yi = `mousedown.bs.${Bo}`, xd = { className: 'modal-backdrop', clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: 'body' }, Nd = { className: 'string', clickCallback: '(function|null)', isAnimated: 'boolean', isVisible: 'boolean', rootElement: '(element|string)' }; class Ko extends It {constructor(e) { super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null } static get Default() { return xd } static get DefaultType() { return Nd } static get NAME() { return Bo }show(e) { if (!this._config.isVisible) { Y(e); return } this._append(); const t = this._getElement(); this._config.isAnimated && kt(t), t.classList.add(qi), this._emulateAnimation(() => { Y(e) }) }hide(e) { if (!this._config.isVisible) { Y(e); return } this._getElement().classList.remove(qi), this._emulateAnimation(() => { this.dispose(), Y(e) }) }dispose() { this._isAppended && (w.off(this._element, Yi), this._element.remove(), this._isAppended = !1) }_getElement() { if (!this._element) { const e = document.createElement('div'); e.className = this._config.className, this._config.isAnimated && e.classList.add(Cd), this._element = e } return this._element }_configAfterMerge(e) { return e.rootElement = xe(e.rootElement), e }_append() { if (this._isAppended) return; const e = this._getElement(); this._config.rootElement.append(e), w.on(e, Yi, () => { Y(this._config.clickCallback) }), this._isAppended = !0 }_emulateAnimation(e) { No(e, this._getElement(), this._config.isAnimated) }} const $d = 'focustrap', Ld = 'bs.focustrap', _n = `.${Ld}`, Dd = `focusin${_n}`, Rd = `keydown.tab${_n}`, Pd = 'Tab', kd = 'forward', Gi = 'backward', Id = { autofocus: !0, trapElement: null }, Fd = { autofocus: 'boolean', trapElement: 'element' }; class Wo extends It {constructor(e) { super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null } static get Default() { return Id } static get DefaultType() { return Fd } static get NAME() { return $d }activate() { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), w.off(document, _n), w.on(document, Dd, e => this._handleFocusin(e)), w.on(document, Rd, e => this._handleKeydown(e)), this._isActive = !0) }deactivate() { this._isActive && (this._isActive = !1, w.off(document, _n)) }_handleFocusin(e) { const { trapElement: t } = this._config; if (e.target === document || e.target === t || t.contains(e.target)) return; const s = C.focusableChildren(t); s.length === 0 ? t.focus() : this._lastTabNavDirection === Gi ? s[s.length - 1].focus() : s[0].focus() }_handleKeydown(e) { e.key === Pd && (this._lastTabNavDirection = e.shiftKey ? Gi : kd) }} const Ji = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top', Xi = '.sticky-top', qt = 'padding-right', Qi = 'margin-right'; class bs {constructor() { this._element = document.body }getWidth() { const e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e) }hide() { const e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, qt, t => t + e), this._setElementAttributes(Ji, qt, t => t + e), this._setElementAttributes(Xi, Qi, t => t - e) }reset() { this._resetElementAttributes(this._element, 'overflow'), this._resetElementAttributes(this._element, qt), this._resetElementAttributes(Ji, qt), this._resetElementAttributes(Xi, Qi) }isOverflowing() { return this.getWidth() > 0 }_disableOverFlow() { this._saveInitialAttribute(this._element, 'overflow'), this._element.style.overflow = 'hidden' }_setElementAttributes(e, t, s) { const i = this.getWidth(), r = (o) => { if (o !== this._element && window.innerWidth > o.clientWidth + i) return; this._saveInitialAttribute(o, t); const a = window.getComputedStyle(o).getPropertyValue(t); o.style.setProperty(t, `${s(Number.parseFloat(a))}px`) }; this._applyManipulationCallback(e, r) }_saveInitialAttribute(e, t) { const s = e.style.getPropertyValue(t); s && ve.setDataAttribute(e, t, s) }_resetElementAttributes(e, t) { const s = (i) => { const r = ve.getDataAttribute(i, t); if (r === null) { i.style.removeProperty(t); return }ve.removeDataAttribute(i, t), i.style.setProperty(t, r) }; this._applyManipulationCallback(e, s) }_applyManipulationCallback(e, t) { if (ye(e)) { t(e); return } for (const s of C.find(e, this._element))t(s) }} const Md = 'modal', Vd = 'bs.modal', ie = `.${Vd}`, jd = '.data-api', Hd = 'Escape', Ud = `hide${ie}`, Bd = `hidePrevented${ie}`, zo = `hidden${ie}`, qo = `show${ie}`, Kd = `shown${ie}`, Wd = `resize${ie}`, zd = `click.dismiss${ie}`, qd = `mousedown.dismiss${ie}`, Yd = `keydown.dismiss${ie}`, Gd = `click${ie}${jd}`, Zi = 'modal-open', Jd = 'fade', er = 'show', Jn = 'modal-static', Xd = '.modal.show', Qd = '.modal-dialog', Zd = '.modal-body', eh = '[data-bs-toggle="modal"]', th = { backdrop: !0, focus: !0, keyboard: !0 }, nh = { backdrop: '(boolean|string)', focus: 'boolean', keyboard: 'boolean' }; class Ye extends le {constructor(e, t) { super(e, t), this._dialog = C.findOne(Qd, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new bs(), this._addEventListeners() } static get Default() { return th } static get DefaultType() { return nh } static get NAME() { return Md }toggle(e) { return this._isShown ? this.hide() : this.show(e) }show(e) { this._isShown || this._isTransitioning || w.trigger(this._element, qo, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Zi), this._adjustDialog(), this._backdrop.show(() => this._showElement(e))) }hide() { !this._isShown || this._isTransitioning || w.trigger(this._element, Ud).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(er), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())) }dispose() { w.off(window, ie), w.off(this._dialog, ie), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() }handleUpdate() { this._adjustDialog() }_initializeBackDrop() { return new Ko({ isVisible: !!this._config.backdrop, isAnimated: this._isAnimated() }) }_initializeFocusTrap() { return new Wo({ trapElement: this._element }) }_showElement(e) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.scrollTop = 0; const t = C.findOne(Zd, this._dialog); t && (t.scrollTop = 0), kt(this._element), this._element.classList.add(er); const s = () => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, w.trigger(this._element, Kd, { relatedTarget: e }) }; this._queueCallback(s, this._dialog, this._isAnimated()) }_addEventListeners() { w.on(this._element, Yd, (e) => { if (e.key === Hd) { if (this._config.keyboard) { this.hide(); return } this._triggerBackdropTransition() } }), w.on(window, Wd, () => { this._isShown && !this._isTransitioning && this._adjustDialog() }), w.on(this._element, qd, (e) => { w.one(this._element, zd, (t) => { if (!(this._element !== e.target || this._element !== t.target)) { if (this._config.backdrop === 'static') { this._triggerBackdropTransition(); return } this._config.backdrop && this.hide() } }) }) }_hideModal() { this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove(Zi), this._resetAdjustments(), this._scrollBar.reset(), w.trigger(this._element, zo) }) }_isAnimated() { return this._element.classList.contains(Jd) }_triggerBackdropTransition() { if (w.trigger(this._element, Bd).defaultPrevented) return; const t = this._element.scrollHeight > document.documentElement.clientHeight, s = this._element.style.overflowY; s === 'hidden' || this._element.classList.contains(Jn) || (t || (this._element.style.overflowY = 'hidden'), this._element.classList.add(Jn), this._queueCallback(() => { this._element.classList.remove(Jn), this._queueCallback(() => { this._element.style.overflowY = s }, this._dialog) }, this._dialog), this._element.focus()) }_adjustDialog() { const e = this._element.scrollHeight > document.documentElement.clientHeight, t = this._scrollBar.getWidth(), s = t > 0; if (s && !e) { const i = se() ? 'paddingLeft' : 'paddingRight'; this._element.style[i] = `${t}px` } if (!s && e) { const i = se() ? 'paddingRight' : 'paddingLeft'; this._element.style[i] = `${t}px` } }_resetAdjustments() { this._element.style.paddingLeft = '', this._element.style.paddingRight = '' } static jQueryInterface(e, t) { return this.each(function () { const s = Ye.getOrCreateInstance(this, e); if (typeof e == 'string') { if (typeof s[e] > 'u') throw new TypeError(`No method named "${e}"`); s[e](t) } }) }}w.on(document, Gd, eh, function (n) { const e = C.getElementFromSelector(this); ['A', 'AREA'].includes(this.tagName) && n.preventDefault(), w.one(e, qo, (i) => { i.defaultPrevented || w.one(e, zo, () => { gt(this) && this.focus() }) }); const t = C.findOne(Xd); t && Ye.getInstance(t).hide(), Ye.getOrCreateInstance(e).toggle(this) }); $n(Ye); re(Ye); const sh = 'offcanvas', ih = 'bs.offcanvas', Se = `.${ih}`, Yo = '.data-api', rh = `load${Se}${Yo}`, oh = 'Escape', tr = 'show', nr = 'showing', sr = 'hiding', ah = 'offcanvas-backdrop', Go = '.offcanvas.show', lh = `show${Se}`, ch = `shown${Se}`, uh = `hide${Se}`, ir = `hidePrevented${Se}`, Jo = `hidden${Se}`, fh = `resize${Se}`, dh = `click${Se}${Yo}`, hh = `keydown.dismiss${Se}`, ph = '[data-bs-toggle="offcanvas"]', mh = { backdrop: !0, keyboard: !0, scroll: !1 }, gh = { backdrop: '(boolean|string)', keyboard: 'boolean', scroll: 'boolean' }; class $e extends le {constructor(e, t) { super(e, t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default() { return mh } static get DefaultType() { return gh } static get NAME() { return sh }toggle(e) { return this._isShown ? this.hide() : this.show(e) }show(e) { if (this._isShown || w.trigger(this._element, lh, { relatedTarget: e }).defaultPrevented) return; this._isShown = !0, this._backdrop.show(), this._config.scroll || new bs().hide(), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.classList.add(nr); const s = () => { (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(tr), this._element.classList.remove(nr), w.trigger(this._element, ch, { relatedTarget: e }) }; this._queueCallback(s, this._element, !0) }hide() { if (!this._isShown || w.trigger(this._element, uh).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(sr), this._backdrop.hide(); const t = () => { this._element.classList.remove(tr, sr), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._config.scroll || new bs().reset(), w.trigger(this._element, Jo) }; this._queueCallback(t, this._element, !0) }dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() }_initializeBackDrop() { const e = () => { if (this._config.backdrop === 'static') { w.trigger(this._element, ir); return } this.hide() }, t = !!this._config.backdrop; return new Ko({ className: ah, isVisible: t, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: t ? e : null }) }_initializeFocusTrap() { return new Wo({ trapElement: this._element }) }_addEventListeners() { w.on(this._element, hh, (e) => { if (e.key === oh) { if (this._config.keyboard) { this.hide(); return }w.trigger(this._element, ir) } }) } static jQueryInterface(e) { return this.each(function () { const t = $e.getOrCreateInstance(this, e); if (typeof e == 'string') { if (t[e] === void 0 || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}w.on(document, dh, ph, function (n) { const e = C.getElementFromSelector(this); if (['A', 'AREA'].includes(this.tagName) && n.preventDefault(), Ne(this)) return; w.one(e, Jo, () => { gt(this) && this.focus() }); const t = C.findOne(Go); t && t !== e && $e.getInstance(t).hide(), $e.getOrCreateInstance(e).toggle(this) }); w.on(window, rh, () => { for (const n of C.find(Go))$e.getOrCreateInstance(n).show() }); w.on(window, fh, () => { for (const n of C.find('[aria-modal][class*=show][class*=offcanvas-]'))getComputedStyle(n).position !== 'fixed' && $e.getOrCreateInstance(n).hide() }); $n($e); re($e); const _h = /^aria-[\w-]*$/i, Xo = { '*': ['class', 'dir', 'id', 'lang', 'role', _h], 'a': ['target', 'href', 'title', 'rel'], 'area': [], 'b': [], 'br': [], 'col': [], 'code': [], 'dd': [], 'div': [], 'dl': [], 'dt': [], 'em': [], 'hr': [], 'h1': [], 'h2': [], 'h3': [], 'h4': [], 'h5': [], 'h6': [], 'i': [], 'img': ['src', 'srcset', 'alt', 'title', 'width', 'height'], 'li': [], 'ol': [], 'p': [], 'pre': [], 's': [], 'small': [], 'span': [], 'sub': [], 'sup': [], 'strong': [], 'u': [], 'ul': [] }, Eh = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']), bh = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, yh = (n, e) => { const t = n.nodeName.toLowerCase(); return e.includes(t) ? Eh.has(t) ? !!bh.test(n.nodeValue) : !0 : e.filter(s => s instanceof RegExp).some(s => s.test(t)) }; function vh(n, e, t) { if (!n.length) return n; if (t && typeof t == 'function') return t(n); const i = new window.DOMParser().parseFromString(n, 'text/html'), r = [].concat(...i.body.querySelectorAll('*')); for (const o of r) { const a = o.nodeName.toLowerCase(); if (!Object.keys(e).includes(a)) { o.remove(); continue } const l = [].concat(...o.attributes), c = [].concat(e['*'] || [], e[a] || []); for (const u of l)yh(u, c) || o.removeAttribute(u.nodeName) } return i.body.innerHTML } const wh = 'TemplateFactory', Sh = { allowList: Xo, content: {}, extraClass: '', html: !1, sanitize: !0, sanitizeFn: null, template: '<div></div>' }, Th = { allowList: 'object', content: 'object', extraClass: '(string|function)', html: 'boolean', sanitize: 'boolean', sanitizeFn: '(null|function)', template: 'string' }, Oh = { entry: '(string|element|function|null)', selector: '(string|element)' }; class Ah extends It {constructor(e) { super(), this._config = this._getConfig(e) } static get Default() { return Sh } static get DefaultType() { return Th } static get NAME() { return wh }getContent() { return Object.values(this._config.content).map(e => this._resolvePossibleFunction(e)).filter(Boolean) }hasContent() { return this.getContent().length > 0 }changeContent(e) { return this._checkContent(e), this._config.content = { ...this._config.content, ...e }, this }toHtml() { const e = document.createElement('div'); e.innerHTML = this._maybeSanitize(this._config.template); for (const [i, r] of Object.entries(this._config.content)) this._setContent(e, r, i); const t = e.children[0], s = this._resolvePossibleFunction(this._config.extraClass); return s && t.classList.add(...s.split(' ')), t }_typeCheckConfig(e) { super._typeCheckConfig(e), this._checkContent(e.content) }_checkContent(e) { for (const [t, s] of Object.entries(e)) super._typeCheckConfig({ selector: t, entry: s }, Oh) }_setContent(e, t, s) { const i = C.findOne(s, e); if (i) { if (t = this._resolvePossibleFunction(t), !t) { i.remove(); return } if (ye(t)) { this._putElementInTemplate(xe(t), i); return } if (this._config.html) { i.innerHTML = this._maybeSanitize(t); return }i.textContent = t } }_maybeSanitize(e) { return this._config.sanitize ? vh(e, this._config.allowList, this._config.sanitizeFn) : e }_resolvePossibleFunction(e) { return Y(e, [void 0, this]) }_putElementInTemplate(e, t) { if (this._config.html) { t.innerHTML = '', t.append(e); return }t.textContent = e.textContent }} const Ch = 'tooltip', xh = new Set(['sanitize', 'allowList', 'sanitizeFn']), Xn = 'fade', Nh = 'modal', Yt = 'show', $h = '.tooltip-inner', rr = `.${Nh}`, or = 'hide.bs.modal', St = 'hover', Qn = 'focus', Lh = 'click', Dh = 'manual', Rh = 'hide', Ph = 'hidden', kh = 'show', Ih = 'shown', Fh = 'inserted', Mh = 'click', Vh = 'focusin', jh = 'focusout', Hh = 'mouseenter', Uh = 'mouseleave', Bh = { AUTO: 'auto', TOP: 'top', RIGHT: se() ? 'left' : 'right', BOTTOM: 'bottom', LEFT: se() ? 'right' : 'left' }, Kh = { allowList: Xo, animation: !0, boundary: 'clippingParents', container: !1, customClass: '', delay: 0, fallbackPlacements: ['top', 'right', 'bottom', 'left'], html: !1, offset: [0, 6], placement: 'top', popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: '', trigger: 'hover focus' }, Wh = { allowList: 'object', animation: 'boolean', boundary: '(string|element)', container: '(string|element|boolean)', customClass: '(string|function)', delay: '(number|object)', fallbackPlacements: 'array', html: 'boolean', offset: '(array|string|function)', placement: '(string|function)', popperConfig: '(null|object|function)', sanitize: 'boolean', sanitizeFn: '(null|function)', selector: '(string|boolean)', template: 'string', title: '(string|element|function)', trigger: 'string' }; class Et extends le {constructor(e, t) { if (typeof To > 'u') throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org/docs/v2/)'); super(e, t), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle() } static get Default() { return Kh } static get DefaultType() { return Wh } static get NAME() { return Ch }enable() { this._isEnabled = !0 }disable() { this._isEnabled = !1 }toggleEnabled() { this._isEnabled = !this._isEnabled }toggle() { if (this._isEnabled) { if (this._isShown()) { this._leave(); return } this._enter() } }dispose() { clearTimeout(this._timeout), w.off(this._element.closest(rr), or, this._hideModalHandler), this._element.getAttribute('data-bs-original-title') && this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title')), this._disposePopper(), super.dispose() }show() { if (this._element.style.display === 'none') throw new Error('Please use show on visible elements'); if (!(this._isWithContent() && this._isEnabled)) return; const e = w.trigger(this._element, this.constructor.eventName(kh)), s = (Co(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (e.defaultPrevented || !s) return; this._disposePopper(); const i = this._getTipElement(); this._element.setAttribute('aria-describedby', i.getAttribute('id')); const { container: r } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (r.append(i), w.trigger(this._element, this.constructor.eventName(Fh))), this._popper = this._createPopper(i), i.classList.add(Yt), 'ontouchstart' in document.documentElement) for (const a of [].concat(...document.body.children))w.on(a, 'mouseover', mn); const o = () => { w.trigger(this._element, this.constructor.eventName(Ih)), this._isHovered === !1 && this._leave(), this._isHovered = !1 }; this._queueCallback(o, this.tip, this._isAnimated()) }hide() { if (!this._isShown() || w.trigger(this._element, this.constructor.eventName(Rh)).defaultPrevented) return; if (this._getTipElement().classList.remove(Yt), 'ontouchstart' in document.documentElement) for (const i of [].concat(...document.body.children))w.off(i, 'mouseover', mn); this._activeTrigger[Lh] = !1, this._activeTrigger[Qn] = !1, this._activeTrigger[St] = !1, this._isHovered = null; const s = () => { this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute('aria-describedby'), w.trigger(this._element, this.constructor.eventName(Ph))) }; this._queueCallback(s, this.tip, this._isAnimated()) }update() { this._popper && this._popper.update() }_isWithContent() { return !!this._getTitle() }_getTipElement() { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip }_createTipElement(e) { const t = this._getTemplateFactory(e).toHtml(); if (!t) return null; t.classList.remove(Xn, Yt), t.classList.add(`bs-${this.constructor.NAME}-auto`); const s = $u(this.constructor.NAME).toString(); return t.setAttribute('id', s), this._isAnimated() && t.classList.add(Xn), t }setContent(e) { this._newContent = e, this._isShown() && (this._disposePopper(), this.show()) }_getTemplateFactory(e) { return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new Ah({ ...this._config, content: e, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory }_getContentForTemplate() { return { [$h]: this._getTitle() } }_getTitle() { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title') }_initializeOnDelegatedTarget(e) { return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig()) }_isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(Xn) }_isShown() { return this.tip && this.tip.classList.contains(Yt) }_createPopper(e) { const t = Y(this._config.placement, [this, e, this._element]), s = Bh[t.toUpperCase()]; return Ms(this._element, e, this._getPopperConfig(s)) }_getOffset() { const { offset: e } = this._config; return typeof e == 'string' ? e.split(',').map(t => Number.parseInt(t, 10)) : typeof e == 'function' ? t => e(t, this._element) : e }_resolvePossibleFunction(e) { return Y(e, [this._element, this._element]) }_getPopperConfig(e) { const t = { placement: e, modifiers: [{ name: 'flip', options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: 'offset', options: { offset: this._getOffset() } }, { name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'arrow', options: { element: `.${this.constructor.NAME}-arrow` } }, { name: 'preSetPlacement', enabled: !0, phase: 'beforeMain', fn: (s) => { this._getTipElement().setAttribute('data-popper-placement', s.state.placement) } }] }; return { ...t, ...Y(this._config.popperConfig, [void 0, t]) } }_setListeners() { const e = this._config.trigger.split(' '); for (const t of e) if (t === 'click')w.on(this._element, this.constructor.eventName(Mh), this._config.selector, (s) => { this._initializeOnDelegatedTarget(s).toggle() }); else if (t !== Dh) { const s = t === St ? this.constructor.eventName(Hh) : this.constructor.eventName(Vh), i = t === St ? this.constructor.eventName(Uh) : this.constructor.eventName(jh); w.on(this._element, s, this._config.selector, (r) => { const o = this._initializeOnDelegatedTarget(r); o._activeTrigger[r.type === 'focusin' ? Qn : St] = !0, o._enter() }), w.on(this._element, i, this._config.selector, (r) => { const o = this._initializeOnDelegatedTarget(r); o._activeTrigger[r.type === 'focusout' ? Qn : St] = o._element.contains(r.relatedTarget), o._leave() }) } this._hideModalHandler = () => { this._element && this.hide() }, w.on(this._element.closest(rr), or, this._hideModalHandler) }_fixTitle() { const e = this._element.getAttribute('title'); e && (!this._element.getAttribute('aria-label') && !this._element.textContent.trim() && this._element.setAttribute('aria-label', e), this._element.setAttribute('data-bs-original-title', e), this._element.removeAttribute('title')) }_enter() { if (this._isShown() || this._isHovered) { this._isHovered = !0; return } this._isHovered = !0, this._setTimeout(() => { this._isHovered && this.show() }, this._config.delay.show) }_leave() { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => { this._isHovered || this.hide() }, this._config.delay.hide)) }_setTimeout(e, t) { clearTimeout(this._timeout), this._timeout = setTimeout(e, t) }_isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0) }_getConfig(e) { const t = ve.getDataAttributes(this._element); for (const s of Object.keys(t))xh.has(s) && delete t[s]; return e = { ...t, ...typeof e == 'object' && e ? e : {} }, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e }_configAfterMerge(e) { return e.container = e.container === !1 ? document.body : xe(e.container), typeof e.delay == 'number' && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title == 'number' && (e.title = e.title.toString()), typeof e.content == 'number' && (e.content = e.content.toString()), e }_getDelegateConfig() { const e = {}; for (const [t, s] of Object.entries(this._config)) this.constructor.Default[t] !== s && (e[t] = s); return e.selector = !1, e.trigger = 'manual', e }_disposePopper() { this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null) } static jQueryInterface(e) { return this.each(function () { const t = Et.getOrCreateInstance(this, e); if (typeof e == 'string') { if (typeof t[e] > 'u') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}re(Et); const zh = 'popover', qh = '.popover-header', Yh = '.popover-body', Gh = { ...Et.Default, content: '', offset: [0, 8], placement: 'right', template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: 'click' }, Jh = { ...Et.DefaultType, content: '(null|string|element|function)' }; class Us extends Et {static get Default() { return Gh } static get DefaultType() { return Jh } static get NAME() { return zh }_isWithContent() { return this._getTitle() || this._getContent() }_getContentForTemplate() { return { [qh]: this._getTitle(), [Yh]: this._getContent() } }_getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(e) { return this.each(function () { const t = Us.getOrCreateInstance(this, e); if (typeof e == 'string') { if (typeof t[e] > 'u') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}re(Us); const Xh = 'scrollspy', Qh = 'bs.scrollspy', Bs = `.${Qh}`, Zh = '.data-api', ep = `activate${Bs}`, ar = `click${Bs}`, tp = `load${Bs}${Zh}`, np = 'dropdown-item', et = 'active', sp = '[data-bs-spy="scroll"]', Zn = '[href]', ip = '.nav, .list-group', lr = '.nav-link', rp = '.nav-item', op = '.list-group-item', ap = `${lr}, ${rp} > ${lr}, ${op}`, lp = '.dropdown', cp = '.dropdown-toggle', up = { offset: null, rootMargin: '0px 0px -25%', smoothScroll: !1, target: null, threshold: [0.1, 0.5, 1] }, fp = { offset: '(number|null)', rootMargin: 'string', smoothScroll: 'boolean', target: 'element', threshold: 'array' }; class Rn extends le {constructor(e, t) { super(e, t), this._targetLinks = new Map(), this._observableSections = new Map(), this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return up } static get DefaultType() { return fp } static get NAME() { return Xh }refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const e of this._observableSections.values()) this._observer.observe(e) }dispose() { this._observer.disconnect(), super.dispose() }_configAfterMerge(e) { return e.target = xe(e.target) || document.body, e.rootMargin = e.offset ? `${e.offset}px 0px -30%` : e.rootMargin, typeof e.threshold == 'string' && (e.threshold = e.threshold.split(',').map(t => Number.parseFloat(t))), e }_maybeEnableSmoothScroll() { this._config.smoothScroll && (w.off(this._config.target, ar), w.on(this._config.target, ar, Zn, (e) => { const t = this._observableSections.get(e.target.hash); if (t) { e.preventDefault(); const s = this._rootElement || window, i = t.offsetTop - this._element.offsetTop; if (s.scrollTo) { s.scrollTo({ top: i, behavior: 'smooth' }); return }s.scrollTop = i } })) }_getNewObserver() { const e = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver(t => this._observerCallback(t), e) }_observerCallback(e) { const t = o => this._targetLinks.get(`#${o.target.id}`), s = (o) => { this._previousScrollData.visibleEntryTop = o.target.offsetTop, this._process(t(o)) }, i = (this._rootElement || document.documentElement).scrollTop, r = i >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = i; for (const o of e) { if (!o.isIntersecting) { this._activeTarget = null, this._clearActiveClass(t(o)); continue } const a = o.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (r && a) { if (s(o), !i) return; continue }!r && !a && s(o) } }_initializeTargetsAndObservables() { this._targetLinks = new Map(), this._observableSections = new Map(); const e = C.find(Zn, this._config.target); for (const t of e) { if (!t.hash || Ne(t)) continue; const s = C.findOne(decodeURI(t.hash), this._element); gt(s) && (this._targetLinks.set(decodeURI(t.hash), t), this._observableSections.set(t.hash, s)) } }_process(e) { this._activeTarget !== e && (this._clearActiveClass(this._config.target), this._activeTarget = e, e.classList.add(et), this._activateParents(e), w.trigger(this._element, ep, { relatedTarget: e })) }_activateParents(e) { if (e.classList.contains(np)) { C.findOne(cp, e.closest(lp)).classList.add(et); return } for (const t of C.parents(e, ip)) for (const s of C.prev(t, ap))s.classList.add(et) }_clearActiveClass(e) { e.classList.remove(et); const t = C.find(`${Zn}.${et}`, e); for (const s of t)s.classList.remove(et) } static jQueryInterface(e) { return this.each(function () { const t = Rn.getOrCreateInstance(this, e); if (typeof e == 'string') { if (t[e] === void 0 || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}w.on(window, tp, () => { for (const n of C.find(sp))Rn.getOrCreateInstance(n) }); re(Rn); const dp = 'tab', hp = 'bs.tab', Je = `.${hp}`, pp = `hide${Je}`, mp = `hidden${Je}`, gp = `show${Je}`, _p = `shown${Je}`, Ep = `click${Je}`, bp = `keydown${Je}`, yp = `load${Je}`, vp = 'ArrowLeft', cr = 'ArrowRight', wp = 'ArrowUp', ur = 'ArrowDown', es = 'Home', fr = 'End', Ue = 'active', dr = 'fade', ts = 'show', Sp = 'dropdown', Qo = '.dropdown-toggle', Tp = '.dropdown-menu', ns = `:not(${Qo})`, Op = '.list-group, .nav, [role="tablist"]', Ap = '.nav-item, .list-group-item', Cp = `.nav-link${ns}, .list-group-item${ns}, [role="tab"]${ns}`, Zo = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', ss = `${Cp}, ${Zo}`, xp = `.${Ue}[data-bs-toggle="tab"], .${Ue}[data-bs-toggle="pill"], .${Ue}[data-bs-toggle="list"]`; class dt extends le {constructor(e) { super(e), this._parent = this._element.closest(Op), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), w.on(this._element, bp, t => this._keydown(t))) } static get NAME() { return dp }show() { const e = this._element; if (this._elemIsActive(e)) return; const t = this._getActiveElem(), s = t ? w.trigger(t, pp, { relatedTarget: e }) : null; w.trigger(e, gp, { relatedTarget: t }).defaultPrevented || s && s.defaultPrevented || (this._deactivate(t, e), this._activate(e, t)) }_activate(e, t) { if (!e) return; e.classList.add(Ue), this._activate(C.getElementFromSelector(e)); const s = () => { if (e.getAttribute('role') !== 'tab') { e.classList.add(ts); return }e.removeAttribute('tabindex'), e.setAttribute('aria-selected', !0), this._toggleDropDown(e, !0), w.trigger(e, _p, { relatedTarget: t }) }; this._queueCallback(s, e, e.classList.contains(dr)) }_deactivate(e, t) { if (!e) return; e.classList.remove(Ue), e.blur(), this._deactivate(C.getElementFromSelector(e)); const s = () => { if (e.getAttribute('role') !== 'tab') { e.classList.remove(ts); return }e.setAttribute('aria-selected', !1), e.setAttribute('tabindex', '-1'), this._toggleDropDown(e, !1), w.trigger(e, mp, { relatedTarget: t }) }; this._queueCallback(s, e, e.classList.contains(dr)) }_keydown(e) { if (![vp, cr, wp, ur, es, fr].includes(e.key)) return; e.stopPropagation(), e.preventDefault(); const t = this._getChildren().filter(i => !Ne(i)); let s; if ([es, fr].includes(e.key))s = t[e.key === es ? 0 : t.length - 1]; else { const i = [cr, ur].includes(e.key); s = Vs(t, e.target, i, !0) }s && (s.focus({ preventScroll: !0 }), dt.getOrCreateInstance(s).show()) }_getChildren() { return C.find(ss, this._parent) }_getActiveElem() { return this._getChildren().find(e => this._elemIsActive(e)) || null }_setInitialAttributes(e, t) { this._setAttributeIfNotExists(e, 'role', 'tablist'); for (const s of t) this._setInitialAttributesOnChild(s) }_setInitialAttributesOnChild(e) { e = this._getInnerElement(e); const t = this._elemIsActive(e), s = this._getOuterElement(e); e.setAttribute('aria-selected', t), s !== e && this._setAttributeIfNotExists(s, 'role', 'presentation'), t || e.setAttribute('tabindex', '-1'), this._setAttributeIfNotExists(e, 'role', 'tab'), this._setInitialAttributesOnTargetPanel(e) }_setInitialAttributesOnTargetPanel(e) { const t = C.getElementFromSelector(e); t && (this._setAttributeIfNotExists(t, 'role', 'tabpanel'), e.id && this._setAttributeIfNotExists(t, 'aria-labelledby', `${e.id}`)) }_toggleDropDown(e, t) { const s = this._getOuterElement(e); if (!s.classList.contains(Sp)) return; const i = (r, o) => { const a = C.findOne(r, s); a && a.classList.toggle(o, t) }; i(Qo, Ue), i(Tp, ts), s.setAttribute('aria-expanded', t) }_setAttributeIfNotExists(e, t, s) { e.hasAttribute(t) || e.setAttribute(t, s) }_elemIsActive(e) { return e.classList.contains(Ue) }_getInnerElement(e) { return e.matches(ss) ? e : C.findOne(ss, e) }_getOuterElement(e) { return e.closest(Ap) || e } static jQueryInterface(e) { return this.each(function () { const t = dt.getOrCreateInstance(this); if (typeof e == 'string') { if (t[e] === void 0 || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}w.on(document, Ep, Zo, function (n) { ['A', 'AREA'].includes(this.tagName) && n.preventDefault(), !Ne(this) && dt.getOrCreateInstance(this).show() }); w.on(window, yp, () => { for (const n of C.find(xp))dt.getOrCreateInstance(n) }); re(dt); const Np = 'toast', $p = 'bs.toast', Pe = `.${$p}`, Lp = `mouseover${Pe}`, Dp = `mouseout${Pe}`, Rp = `focusin${Pe}`, Pp = `focusout${Pe}`, kp = `hide${Pe}`, Ip = `hidden${Pe}`, Fp = `show${Pe}`, Mp = `shown${Pe}`, Vp = 'fade', hr = 'hide', Gt = 'show', Jt = 'showing', jp = { animation: 'boolean', autohide: 'boolean', delay: 'number' }, Hp = { animation: !0, autohide: !0, delay: 5e3 }; class Pn extends le {constructor(e, t) { super(e, t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return Hp } static get DefaultType() { return jp } static get NAME() { return Np }show() { if (w.trigger(this._element, Fp).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add(Vp); const t = () => { this._element.classList.remove(Jt), w.trigger(this._element, Mp), this._maybeScheduleHide() }; this._element.classList.remove(hr), kt(this._element), this._element.classList.add(Gt, Jt), this._queueCallback(t, this._element, this._config.animation) }hide() { if (!this.isShown() || w.trigger(this._element, kp).defaultPrevented) return; const t = () => { this._element.classList.add(hr), this._element.classList.remove(Jt, Gt), w.trigger(this._element, Ip) }; this._element.classList.add(Jt), this._queueCallback(t, this._element, this._config.animation) }dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(Gt), super.dispose() }isShown() { return this._element.classList.contains(Gt) }_maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide() }, this._config.delay))) }_onInteraction(e, t) { switch (e.type) { case 'mouseover':case 'mouseout':{ this._hasMouseInteraction = t; break } case 'focusin':case 'focusout':{ this._hasKeyboardInteraction = t; break } } if (t) { this._clearTimeout(); return } const s = e.relatedTarget; this._element === s || this._element.contains(s) || this._maybeScheduleHide() }_setListeners() { w.on(this._element, Lp, e => this._onInteraction(e, !0)), w.on(this._element, Dp, e => this._onInteraction(e, !1)), w.on(this._element, Rp, e => this._onInteraction(e, !0)), w.on(this._element, Pp, e => this._onInteraction(e, !1)) }_clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(e) { return this.each(function () { const t = Pn.getOrCreateInstance(this, e); if (typeof e == 'string') { if (typeof t[e] > 'u') throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}$n(Pn); re(Pn); const Up = (n, e) => { const t = document.getElementById('modal'), s = new Ye(t), i = t.querySelector('h5'), r = t.querySelector('.modal-body'), o = t.querySelector('#a'), l = t.querySelector('.modal-footer').querySelector('button'); n.addEventListener('click', () => { i.textContent = e.title, r.textContent = e.description, o.href = e.link, console.log(n.id), document.getElementById(`${n.id}`).classList.remove('fw-bold', 'fw-normal'), s.show() }), l.addEventListener('click', () => { s.hide() }) }, Bp = (n, e, t) => { const s = document.querySelector('#postUl'); for (const i of n) { if (e.has(i.link)) continue; const r = document.createElement('li'); r.classList.add('list-group-item', 'd-flex', 'justify-content-between', 'align-items-start', 'border-0', 'border-end-0'); const o = document.createElement('button'); o.classList.add('btn', 'btn-outline-primary', 'btn-sm'), o.id = i.id, o.textContent = t.t('view'), o.dataset.toggle = 'modal', o.dataset.target = '#modal'; const a = document.createElement('a'); a.id = i.id, a.classList.add('fw-bold'), a.href = i.link, a.textContent = i.title, Up(o, i), s.prepend(r), r.prepend(a), r.append(o) } }, Kp = (n, e) => {
    try { const t = new DOMParser(); let s = 1; const i = t.parseFromString(n, 'application/xml'), r = i.querySelector('title'), a = i.querySelector('description').textContent, c = { feed: r.textContent, description: a, posts: [] }, u = i.querySelectorAll('item'); for (const f of u) { const p = f.querySelector('title'), h = f.querySelector('link'), d = f.querySelector('description'), _ = { id: s, title: p.textContent, link: h.textContent, description: d.textContent }; c.posts.push(_), s += 1 } return c }
    catch { throw new Error(e.t('RssNull')) }
  }, ea = async (n, e, t, s, i) => {
    try { s.error = null; const r = await Vc(n, e), o = Kp(r.data.contents, e); i.classList.replace('text-danger', 'text-success'), i.textContent = e.t('success'), jc(o), Bp(o.posts, t.actualLinks, e), o.posts.forEach(a => t.actualLinks.add(a.link)) }
    catch (r) { r.code === 'ECONNABORTED' ? s.error = 'networkErr' : s.error = r.message }
  }; async function Wp(n, e, t, s, i) { for (const r of n)ea(r, t, e, s, i) } const zp = async () => new Promise(n => setTimeout(n, 5e3)), qp = async (n, e, t, s, i, r = !0) => { for (;await zp(), Wp(n, e, t, s, i), r !== !1;); }, Oe = '.', Ks = Symbol('target'), ta = Symbol('unsubscribe'); function ys(n) { return n instanceof Date || n instanceof Set || n instanceof Map || n instanceof WeakSet || n instanceof WeakMap || ArrayBuffer.isView(n) } function Yp(n) { return (typeof n == 'object' ? n === null : typeof n != 'function') || n instanceof RegExp } const U = Array.isArray; function En(n) { return typeof n == 'symbol' } const z = { after(n, e) { return U(n) ? n.slice(e.length) : e === '' ? n : n.slice(e.length + 1) }, concat(n, e) { return U(n) ? (n = [...n], e && n.push(e), n) : e && e.toString !== void 0 ? (n !== '' && (n += Oe), En(e) ? n + e.toString() : n + e) : n }, initial(n) { if (U(n)) return n.slice(0, -1); if (n === '') return n; const e = n.lastIndexOf(Oe); return e === -1 ? '' : n.slice(0, e) }, last(n) { if (U(n)) return n.at(-1) ?? ''; if (n === '') return n; const e = n.lastIndexOf(Oe); return e === -1 ? n : n.slice(e + 1) }, walk(n, e) { if (U(n)) for (const t of n)e(t); else if (n !== '') { let t = 0, s = n.indexOf(Oe); if (s === -1)e(n); else for (;t < n.length;)s === -1 && (s = n.length), e(n.slice(t, s)), t = s + 1, s = n.indexOf(Oe, t) } }, get(n, e) { return this.walk(e, (t) => { n && (n = n[t]) }), n }, isSubPath(n, e) { if (U(n)) { if (n.length < e.length) return !1; for (let t = 0; t < e.length; t++) if (n[t] !== e[t]) return !1; return !0 } return n.length < e.length ? !1 : n === e ? !0 : n.startsWith(e) ? n[e.length] === Oe : !1 }, isRootPath(n) { return U(n) ? n.length === 0 : n === '' } }; function Gp(n) { return typeof n == 'object' && typeof n.next == 'function' } function Jp(n, e, t, s, i) {
  const r = n.next; if (e.name === 'entries')n.next = function () { const o = r.call(this); return o.done === !1 && (o.value[0] = i(o.value[0], e, o.value[0], s), o.value[1] = i(o.value[1], e, o.value[0], s)), o }; else if (e.name === 'values') { const o = t[Ks].keys(); n.next = function () { const a = r.call(this); return a.done === !1 && (a.value = i(a.value, e, o.next().value, s)), a } }
  else n.next = function () { const o = r.call(this); return o.done === !1 && (o.value = i(o.value, e, o.value, s)), o }; return n
} function pr(n, e, t) { return n.isUnsubscribed || e.ignoreSymbols && En(t) || e.ignoreUnderscores && t.charAt(0) === '_' || 'ignoreKeys' in e && e.ignoreKeys.includes(t) } class Xp {constructor(e) { this._equals = e, this._proxyCache = new WeakMap(), this._pathCache = new WeakMap(), this.isUnsubscribed = !1 }_getDescriptorCache() { return this._descriptorCache === void 0 && (this._descriptorCache = new WeakMap()), this._descriptorCache }_getProperties(e) { const t = this._getDescriptorCache(); let s = t.get(e); return s === void 0 && (s = {}, t.set(e, s)), s }_getOwnPropertyDescriptor(e, t) { if (this.isUnsubscribed) return Reflect.getOwnPropertyDescriptor(e, t); const s = this._getProperties(e); let i = s[t]; return i === void 0 && (i = Reflect.getOwnPropertyDescriptor(e, t), s[t] = i), i }getProxy(e, t, s, i) { if (this.isUnsubscribed) return e; const r = e[i], o = r ?? e; this._pathCache.set(o, t); let a = this._proxyCache.get(o); return a === void 0 && (a = r === void 0 ? new Proxy(e, s) : e, this._proxyCache.set(o, a)), a }getPath(e) { return this.isUnsubscribed ? void 0 : this._pathCache.get(e) }isDetached(e, t) { return !Object.is(e, z.get(t, this.getPath(e))) }defineProperty(e, t, s) { return Reflect.defineProperty(e, t, s) ? (this.isUnsubscribed || (this._getProperties(e)[t] = s), !0) : !1 }setProperty(e, t, s, i, r) { if (!this._equals(r, s) || !(t in e)) { const o = this._getOwnPropertyDescriptor(e, t); return o !== void 0 && 'set' in o ? Reflect.set(e, t, s, i) : Reflect.set(e, t, s) } return !0 }deleteProperty(e, t, s) { if (Reflect.deleteProperty(e, t)) { if (!this.isUnsubscribed) { const i = this._getDescriptorCache().get(e); i && (delete i[t], this._pathCache.delete(s)) } return !0 } return !1 }isSameDescriptor(e, t, s) { const i = this._getOwnPropertyDescriptor(t, s); return e !== void 0 && i !== void 0 && Object.is(e.value, i.value) && (e.writable || !1) === (i.writable || !1) && (e.enumerable || !1) === (i.enumerable || !1) && (e.configurable || !1) === (i.configurable || !1) && e.get === i.get && e.set === i.set }isGetInvariant(e, t) { const s = this._getOwnPropertyDescriptor(e, t); return s !== void 0 && s.configurable !== !0 && s.writable !== !0 }unsubscribe() { this._descriptorCache = null, this._pathCache = null, this._proxyCache = null, this.isUnsubscribed = !0 }} function vs(n) { return toString.call(n) === '[object Object]' } function Xt() { return !0 } function tt(n, e) { return n.length !== e.length || n.some((t, s) => e[s] !== t) } const na = new Set(['hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf']), Qp = new Set(['concat', 'includes', 'indexOf', 'join', 'keys', 'lastIndexOf']), sa = { push: Xt, pop: Xt, shift: Xt, unshift: Xt, copyWithin: tt, reverse: tt, sort: tt, splice: tt, flat: tt, fill: tt }, Zp = new Set([...na, ...Qp, ...Object.keys(sa)]); function Qt(n, e) { if (n.size !== e.size) return !0; for (const t of n) if (!e.has(t)) return !0; return !1 } const ia = ['keys', 'values', 'entries'], ra = new Set(['has', 'toString']), oa = { add: Qt, clear: Qt, delete: Qt, forEach: Qt }, em = new Set([...ra, ...Object.keys(oa), ...ia]); function Zt(n, e) { if (n.size !== e.size) return !0; let t; for (const [s, i] of n) if (t = e.get(s), t !== i || t === void 0 && !e.has(s)) return !0; return !1 } const tm = new Set([...ra, 'get']), aa = { set: Zt, clear: Zt, delete: Zt, forEach: Zt }, nm = new Set([...tm, ...Object.keys(aa), ...ia]); class Le {constructor(e, t, s, i) { this._path = t, this._isChanged = !1, this._clonedCache = new Set(), this._hasOnValidate = i, this._changes = i ? [] : null, this.clone = t === void 0 ? e : this._shallowClone(e) } static isHandledMethod(e) { return na.has(e) }_shallowClone(e) { let t = e; if (vs(e))t = { ...e }; else if (U(e) || ArrayBuffer.isView(e))t = [...e]; else if (e instanceof Date)t = new Date(e); else if (e instanceof Set)t = new Set([...e].map(s => this._shallowClone(s))); else if (e instanceof Map) { t = new Map(); for (const [s, i] of e.entries())t.set(s, this._shallowClone(i)) } return this._clonedCache.add(t), t }preferredThisArg(e, t, s, i) { return e ? (U(i) ? this._onIsChanged = sa[t] : i instanceof Set ? this._onIsChanged = oa[t] : i instanceof Map && (this._onIsChanged = aa[t]), i) : s }update(e, t, s) { const i = z.after(e, this._path); if (t !== 'length') { let r = this.clone; z.walk(i, (o) => { r != null && r[o] && (this._clonedCache.has(r[o]) || (r[o] = this._shallowClone(r[o])), r = r[o]) }), this._hasOnValidate && this._changes.push({ path: i, property: t, previous: s }), r != null && r[t] && (r[t] = s) } this._isChanged = !0 }undo(e) { let t; for (let s = this._changes.length - 1; s !== -1; s--)t = this._changes[s], z.get(e, t.path)[t.property] = t.previous }isChanged(e) { return this._onIsChanged === void 0 ? this._isChanged : this._onIsChanged(this.clone, e) }isPathApplicable(e) { return z.isRootPath(this._path) || z.isSubPath(e, this._path) }} class mr extends Le {static isHandledMethod(e) { return Zp.has(e) }} class sm extends Le {undo(e) { e.setTime(this.clone.getTime()) }isChanged(e, t) { return !t(this.clone.valueOf(), e.valueOf()) }} class gr extends Le {static isHandledMethod(e) { return em.has(e) }undo(e) { for (const t of this.clone)e.add(t); for (const t of e) this.clone.has(t) || e.delete(t) }} class _r extends Le {static isHandledMethod(e) { return nm.has(e) }undo(e) { for (const [t, s] of this.clone.entries())e.set(t, s); for (const t of e.keys()) this.clone.has(t) || e.delete(t) }} class im extends Le {constructor(e, t, s, i) { super(void 0, t, s, i), this._argument1 = s[0], this._weakValue = e.has(this._argument1) }isChanged(e) { return this._weakValue !== e.has(this._argument1) }undo(e) { this._weakValue && !e.has(this._argument1) ? e.add(this._argument1) : e.delete(this._argument1) }} class rm extends Le {constructor(e, t, s, i) { super(void 0, t, s, i), this._weakKey = s[0], this._weakHas = e.has(this._weakKey), this._weakValue = e.get(this._weakKey) }isChanged(e) { return this._weakValue !== e.get(this._weakKey) }undo(e) { const t = e.has(this._weakKey); this._weakHas && !t ? e.set(this._weakKey, this._weakValue) : !this._weakHas && t ? e.delete(this._weakKey) : this._weakValue !== e.get(this._weakKey) && e.set(this._weakKey, this._weakValue) }} class Me {constructor(e) { this._stack = [], this._hasOnValidate = e } static isHandledType(e) { return vs(e) || U(e) || ys(e) } static isHandledMethod(e, t) { return vs(e) ? Le.isHandledMethod(t) : U(e) ? mr.isHandledMethod(t) : e instanceof Set ? gr.isHandledMethod(t) : e instanceof Map ? _r.isHandledMethod(t) : ys(e) } get isCloning() { return this._stack.length > 0 }start(e, t, s) { let i = Le; U(e) ? i = mr : e instanceof Date ? i = sm : e instanceof Set ? i = gr : e instanceof Map ? i = _r : e instanceof WeakSet ? i = im : e instanceof WeakMap && (i = rm), this._stack.push(new i(e, t, s, this._hasOnValidate)) }update(e, t, s) { this._stack.at(-1).update(e, t, s) }preferredThisArg(e, t, s) { const { name: i } = e, r = Me.isHandledMethod(s, i); return this._stack.at(-1).preferredThisArg(r, i, t, s) }isChanged(e, t, s) { return this._stack.at(-1).isChanged(e, t, s) }isPartOfClone(e) { return this._stack.at(-1).isPathApplicable(e) }undo(e) { this._previousClone !== void 0 && this._previousClone.undo(e) }stop() { return this._previousClone = this._stack.pop(), this._previousClone.clone }} const om = { equals: Object.is, isShallow: !1, pathAsArray: !1, ignoreSymbols: !1, ignoreUnderscores: !1, ignoreDetached: !1, details: !1 }, Ws = (n, e, t = {}) => { t = { ...om, ...t }; const s = Symbol('ProxyTarget'), { equals: i, isShallow: r, ignoreDetached: o, details: a } = t, l = new Xp(i), c = typeof t.onValidate == 'function', u = new Me(c), f = (g, E, v, S, O) => !c || u.isCloning || t.onValidate(z.concat(l.getPath(g), E), v, S, O) === !0, p = (g, E, v, S) => { !pr(l, t, E) && !(o && l.isDetached(g, n)) && h(l.getPath(g), E, v, S) }, h = (g, E, v, S, O) => { u.isCloning && u.isPartOfClone(g) ? u.update(g, E, S) : e(z.concat(g, E), v, S, O) }, d = g => g && (g[s] ?? g), _ = (g, E, v, S) => { if (Yp(g) || v === 'constructor' || r && !Me.isHandledMethod(E, v) || pr(l, t, v) || l.isGetInvariant(E, v) || o && l.isDetached(E, n)) return g; S === void 0 && (S = l.getPath(E)); const O = z.concat(S, v), x = l.getPath(g); return x && y(O, x) ? l.getProxy(g, x, b, s) : l.getProxy(g, O, b, s) }, y = (g, E) => { if (En(g) || g.length <= E.length || U(E) && E.length === 0) return !1; const v = U(g) ? g : g.split(Oe), S = U(E) ? E : E.split(Oe); return v.length <= S.length ? !1 : !S.some((O, x) => O !== v[x]) }, b = { get(g, E, v) { if (En(E)) { if (E === s || E === Ks) return g; if (E === ta && !l.isUnsubscribed && l.getPath(g).length === 0) return l.unsubscribe(), g } const S = ys(g) ? Reflect.get(g, E) : Reflect.get(g, E, v); return _(S, g, E) }, set(g, E, v, S) { v = d(v); const O = g[s] ?? g, x = O[E]; if (i(x, v) && E in g) return !0; const A = f(g, E, v, x); return A && l.setProperty(O, E, v, S, x) ? (p(g, E, g[E], x), !0) : !A }, defineProperty(g, E, v) { if (!l.isSameDescriptor(v, g, E)) { const S = g[E]; f(g, E, v.value, S) && l.defineProperty(g, E, v, S) && p(g, E, v.value, S) } return !0 }, deleteProperty(g, E) { if (!Reflect.has(g, E)) return !0; const v = Reflect.get(g, E), S = f(g, E, void 0, v); return S && l.deleteProperty(g, E, v) ? (p(g, E, void 0, v), !0) : !S }, apply(g, E, v) { const S = E[s] ?? E; if (l.isUnsubscribed) return Reflect.apply(g, S, v); if ((a === !1 || a !== !0 && !a.includes(g.name)) && Me.isHandledType(S)) { let O = z.initial(l.getPath(g)); const x = Me.isHandledMethod(S, g.name); u.start(S, O, v); let A = Reflect.apply(g, u.preferredThisArg(g, E, S), x ? v.map(P => d(P)) : v); const D = u.isChanged(S, i), L = u.stop(); if (Me.isHandledType(A) && x && (E instanceof Map && g.name === 'get' && (O = z.concat(O, v[0])), A = l.getProxy(A, O, b)), D) { const P = { name: g.name, args: v, result: A }, R = u.isCloning ? z.initial(O) : O, k = u.isCloning ? z.last(O) : ''; f(z.get(n, R), k, S, L, P) ? h(R, k, S, L, P) : u.undo(S) } return (E instanceof Map || E instanceof Set) && Gp(A) ? Jp(A, g, E, O, _) : A } return Reflect.apply(g, E, v) } }, T = l.getProxy(n, t.pathAsArray ? [] : '', b); return e = e.bind(T), c && (t.onValidate = t.onValidate.bind(T)), T }; Ws.target = n => (n == null ? void 0 : n[Ks]) ?? n; Ws.unsubscribe = n => (n == null ? void 0 : n[ta]) ?? n; const am = (n, e, t, s) => Ws(n, function (r, o, a) { n.error == null ? (e.classList.remove('is-invalid'), e.value = '', e.focus()) : (e.classList.add('is-invalid'), t.textContent = s.t(n.error)) }), lm = async () => { const n = H.createInstance(), e = document.querySelector('form'), t = document.querySelector('input'), s = document.querySelector('#dobavlenie'), i = document.querySelector('label'), r = document.querySelector('p'), o = []; await n.init({ lng: 'ru', resources: { ru: ll } }); const a = { formData: '', actualLinks: new Set(), error: null }, l = am(a, t, r, n); s.textContent = n.t('button'), i.textContent = n.t('holder'), e.addEventListener('input', (c) => { a.formData = c.target.value }), s.addEventListener('click', async (c) => { c.preventDefault(); const u = a.formData, f = await cm(u, o); if (f != null) { l.error = f; return }ea(u, n, a, l, r) }), qp(o, a, n, l, r) }; async function cm(n, e) {
  const t = Ua(e); try { await t.validate(n), e.push(n); return }
  catch (s) { return s.message }
}lm()
